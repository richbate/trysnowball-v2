#!/usr/bin/env node

/**
 * Evaluation Summary Generator
 * Reads JUnit XML + coverage JSON -> emits compact markdown for PR comments
 */

import fs from 'fs';
import path from 'path';

function log(message) {
  console.log(`[${new Date().toISOString()}] ${message}`);
}

function parseJUnitXML(xmlContent, parseStringFn) {
  return new Promise((resolve, reject) => {
    parseStringFn(xmlContent, (err, result) => {
      if (err) reject(err);
      else resolve(result);
    });
  });
}

function extractTestResults(junitData) {
  const testsuites = junitData.testsuites || junitData.testsuite;
  
  if (!testsuites) {
    return { total: 0, passed: 0, failed: 0, skipped: 0, suites: [] };
  }

  const suites = Array.isArray(testsuites.testsuite) ? testsuites.testsuite : [testsuites.testsuite];
  
  let total = 0, passed = 0, failed = 0, skipped = 0;
  const suiteDetails = [];

  suites.forEach(suite => {
    if (!suite || !suite.$) return;
    
    const suiteTests = parseInt(suite.$.tests || '0');
    const suiteFailures = parseInt(suite.$.failures || '0');
    const suiteErrors = parseInt(suite.$.errors || '0');
    const suiteSkipped = parseInt(suite.$.skipped || '0');
    const suitePassed = suiteTests - suiteFailures - suiteErrors - suiteSkipped;
    
    total += suiteTests;
    passed += suitePassed;
    failed += (suiteFailures + suiteErrors);
    skipped += suiteSkipped;

    suiteDetails.push({
      name: suite.$.name || 'Unknown',
      tests: suiteTests,
      passed: suitePassed,
      failed: suiteFailures + suiteErrors,
      skipped: suiteSkipped,
      time: parseFloat(suite.$.time || '0'),
    });
  });

  return { total, passed, failed, skipped, suites: suiteDetails };
}

function parseCoverage(coveragePath) {
  if (!fs.existsSync(coveragePath)) {
    return null;
  }

  try {
    const coverage = JSON.parse(fs.readFileSync(coveragePath, 'utf8'));
    const total = coverage.total;
    
    if (!total) return null;

    return {
      lines: Math.round(total.lines?.pct || 0),
      functions: Math.round(total.functions?.pct || 0),
      branches: Math.round(total.branches?.pct || 0),
      statements: Math.round(total.statements?.pct || 0),
    };
  } catch (err) {
    log(`Warning: Could not parse coverage file: ${err.message}`);
    return null;
  }
}

function generateMarkdownSummary(testResults, coverage) {
  const { total, passed, failed, skipped, suites } = testResults;
  const successRate = total > 0 ? Math.round((passed / total) * 100) : 0;

  let markdown = `## üß™ Evaluation Results\n\n`;
  
  // Overall status
  if (failed > 0) {
    markdown += `‚ùå **Status**: ${failed} test(s) failed\n\n`;
  } else if (total === 0) {
    markdown += `‚ö†Ô∏è **Status**: No tests found\n\n`;
  } else {
    markdown += `‚úÖ **Status**: All tests passed!\n\n`;
  }

  // Test summary
  markdown += `### Test Summary\n`;
  markdown += `- **Total**: ${total} tests\n`;
  markdown += `- **Passed**: ${passed} (${successRate}%)\n`;
  if (failed > 0) markdown += `- **Failed**: ${failed}\n`;
  if (skipped > 0) markdown += `- **Skipped**: ${skipped}\n`;
  markdown += `\n`;

  // Suite breakdown (only show if multiple suites or failures)
  if (suites.length > 1 || failed > 0) {
    markdown += `### Suite Breakdown\n`;
    suites.forEach(suite => {
      const status = suite.failed > 0 ? '‚ùå' : '‚úÖ';
      const timing = suite.time > 0 ? ` (${suite.time.toFixed(2)}s)` : '';
      markdown += `- ${status} **${suite.name}**: ${suite.passed}/${suite.tests} passed${timing}\n`;
    });
    markdown += `\n`;
  }

  // Coverage (if available)
  if (coverage) {
    markdown += `### Coverage Report\n`;
    
    const coverageItems = [
      { name: 'Lines', value: coverage.lines, target: 85 },
      { name: 'Functions', value: coverage.functions, target: 80 },
      { name: 'Branches', value: coverage.branches, target: 70 },
    ];

    coverageItems.forEach(({ name, value, target }) => {
      const status = value >= target ? '‚úÖ' : '‚ö†Ô∏è';
      markdown += `- ${status} **${name}**: ${value}% (target: ${target}%)\n`;
    });
    markdown += `\n`;
  }

  // Action items
  if (failed > 0) {
    markdown += `### ‚ö†Ô∏è Action Required\n`;
    markdown += `Please fix the failing tests before merging.\n\n`;
  } else if (coverage && (coverage.lines < 85 || coverage.functions < 80 || coverage.branches < 70)) {
    markdown += `### üí° Recommendations\n`;
    markdown += `Consider adding tests to improve coverage in core utility functions.\n\n`;
  }

  // Footer
  markdown += `---\n`;
  markdown += `ü§ñ *Generated by evaluation framework*`;

  return markdown;
}

async function main() {
  try {
    log('Starting evaluation summary generation...');

    const reportsDir = path.join(process.cwd(), 'reports');
    const coverageDir = path.join(process.cwd(), 'coverage');
    
    // Read JUnit XML
    const junitPath = path.join(reportsDir, 'junit.xml');
    let testResults = { total: 0, passed: 0, failed: 0, skipped: 0, suites: [] };
    
    if (fs.existsSync(junitPath)) {
      log('Reading JUnit XML results...');
      const xmlContent = fs.readFileSync(junitPath, 'utf8');
      const junitData = await parseJUnitXML(xmlContent, parseString);
      testResults = extractTestResults(junitData);
    } else {
      log('Warning: JUnit XML not found, generating summary without test results');
    }

    // Read coverage
    const coveragePath = path.join(coverageDir, 'coverage-summary.json');
    const coverage = parseCoverage(coveragePath);
    
    if (coverage) {
      log('Coverage data found and parsed');
    } else {
      log('No coverage data available');
    }

    // Generate markdown
    const markdown = generateMarkdownSummary(testResults, coverage);
    
    // Write summary files
    const summaryPath = path.join(reportsDir, 'eval-summary.md');
    const jsonSummaryPath = path.join(reportsDir, 'eval-summary.json');
    
    // Ensure reports directory exists
    if (!fs.existsSync(reportsDir)) {
      fs.mkdirSync(reportsDir, { recursive: true });
    }
    
    fs.writeFileSync(summaryPath, markdown);
    
    // Also write JSON for programmatic use
    const jsonSummary = {
      timestamp: new Date().toISOString(),
      tests: testResults,
      coverage,
      status: testResults.failed > 0 ? 'failed' : 'passed',
      deployReady: testResults.failed === 0,
    };
    
    fs.writeFileSync(jsonSummaryPath, JSON.stringify(jsonSummary, null, 2));

    log(`Summary written to: ${summaryPath}`);
    log(`JSON summary written to: ${jsonSummaryPath}`);

    // Output markdown to stdout for GitHub Actions
    console.log(markdown);
    
    // Exit with appropriate code
    process.exit(testResults.failed > 0 ? 1 : 0);
    
  } catch (error) {
    console.error('Error generating evaluation summary:', error);
    process.exit(1);
  }
}

// Add xml2js as a dependency check with better error handling
let parseString;
try {
  const xml2js = await import('xml2js');
  parseString = xml2js.parseString;
} catch (err) {
  try {
    console.log('Installing xml2js dependency...');
    const { execSync } = await import('child_process');
    execSync('npm install xml2js', { stdio: 'inherit' });
    const xml2js = await import('xml2js');
    parseString = xml2js.parseString;
  } catch (installErr) {
    console.warn('Could not install xml2js, providing fallback...');
    // Provide minimal fallback for parsing
    parseString = (xmlContent, callback) => {
      // Simple fallback - assume no tests if XML parsing fails
      callback(null, {
        testsuites: {
          testsuite: [{
            $: { tests: '0', failures: '0', errors: '0', skipped: '0', time: '0' },
            name: 'fallback'
          }]
        }
      });
    };
  }
}

main();
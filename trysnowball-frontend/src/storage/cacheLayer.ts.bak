/**
 * In-Memory Cache Layer
 * Fast read-through cache to avoid IndexedDB jank in UI components
 */

import { Debt, Payment, Snapshot, getDebts, getPayments, getSnapshots } from './localStore';

interface CacheState {
 debts: Map<string, Debt[]>;   // userId -> debts
 payments: Map<string, Payment[]>; // userId -> payments 
 snapshots: Map<string, Snapshot[]>; // userId -> snapshots
 lastUpdated: Map<string, number>; // storeName -> timestamp
}

class DebtCache {
 private cache: CacheState = {
  debts: new Map(),
  payments: new Map(), 
  snapshots: new Map(),
  lastUpdated: new Map()
 };

 private readonly CACHE_TTL = 30000; // 30 seconds

 // Check if cache is fresh for a given store and user
 private isCacheFresh(storeName: string, userId: string): boolean {
  const cacheKey = `${storeName}:${userId}`;
  const lastUpdated = this.cache.lastUpdated.get(cacheKey) || 0;
  return Date.now() - lastUpdated < this.CACHE_TTL;
 }

 // Update cache timestamp
 private updateCacheTime(storeName: string, userId: string): void {
  const cacheKey = `${storeName}:${userId}`;
  this.cache.lastUpdated.set(cacheKey, Date.now());
 }

 // Debts operations
 async getDebts(userId: string): Promise<Debt[]> {
  if (this.cache.debts.has(userId) && this.isCacheFresh('debts', userId)) {
   return this.cache.debts.get(userId)!;
  }

  // Cache miss - fetch from IndexedDB
  const debts = await getDebts(userId);
  this.cache.debts.set(userId, debts);
  this.updateCacheTime('debts', userId);
  return debts;
 }

 // Invalidate debts cache when data changes
 invalidateDebts(userId: string): void {
  this.cache.debts.delete(userId);
  this.cache.lastUpdated.delete(`debts:${userId}`);
 }

 // Update cache with new debt data
 updateDebtsCache(userId: string, debts: Debt[]): void {
  this.cache.debts.set(userId, debts);
  this.updateCacheTime('debts', userId);
 }

 // Payments operations
 async getPayments(userId: string): Promise<Payment[]> {
  if (this.cache.payments.has(userId) && this.isCacheFresh('payments', userId)) {
   return this.cache.payments.get(userId)!;
  }

  // Cache miss - fetch from IndexedDB
  const payments = await getPayments(userId);
  this.cache.payments.set(userId, payments);
  this.updateCacheTime('payments', userId);
  return payments;
 }

 // Invalidate payments cache when data changes
 invalidatePayments(userId: string): void {
  this.cache.payments.delete(userId);
  this.cache.lastUpdated.delete(`payments:${userId}`);
 }

 // Update cache with new payment data
 updatePaymentsCache(userId: string, payments: Payment[]): void {
  this.cache.payments.set(userId, payments);
  this.updateCacheTime('payments', userId);
 }

 // Snapshots operations
 async getSnapshots(userId: string): Promise<Snapshot[]> {
  if (this.cache.snapshots.has(userId) && this.isCacheFresh('snapshots', userId)) {
   return this.cache.snapshots.get(userId)!;
  }

  // Cache miss - fetch from IndexedDB
  const snapshots = await getSnapshots(userId);
  this.cache.snapshots.set(userId, snapshots);
  this.updateCacheTime('snapshots', userId);
  return snapshots;
 }

 // Invalidate snapshots cache when data changes
 invalidateSnapshots(userId: string): void {
  this.cache.snapshots.delete(userId);
  this.cache.lastUpdated.delete(`snapshots:${userId}`);
 }

 // Update cache with new snapshot data
 updateSnapshotsCache(userId: string, snapshots: Snapshot[]): void {
  this.cache.snapshots.set(userId, snapshots);
  this.updateCacheTime('snapshots', userId);
 }

 // Clear all cached data for a user (useful for logout)
 clearUserCache(userId: string): void {
  this.cache.debts.delete(userId);
  this.cache.payments.delete(userId);
  this.cache.snapshots.delete(userId);
  this.cache.lastUpdated.delete(`debts:${userId}`);
  this.cache.lastUpdated.delete(`payments:${userId}`);
  this.cache.lastUpdated.delete(`snapshots:${userId}`);
 }

 // Clear all cached data
 clearAllCache(): void {
  this.cache.debts.clear();
  this.cache.payments.clear();
  this.cache.snapshots.clear();
  this.cache.lastUpdated.clear();
 }

 // Get cache stats for debugging
 getCacheStats(): {
  debtsUsers: number;
  paymentsUsers: number;
  snapshotsUsers: number;
  totalCacheEntries: number;
 } {
  return {
   debtsUsers: this.cache.debts.size,
   paymentsUsers: this.cache.payments.size,
   snapshotsUsers: this.cache.snapshots.size,
   totalCacheEntries: this.cache.lastUpdated.size
  };
 }
}

// Export singleton instance
export const debtCache = new DebtCache();

// Export for debugging in development
if (process.env.NODE_ENV === 'development') {
 (window as any).__DEBT_CACHE__ = debtCache;
}
/**
 * Unit tests for debtsManager defensive measures
 */

import { debtsManager } from '../debtsManager';

// Mock the localDebtStore
jest.mock('../../data/localDebtStore', () => ({
 localDebtStore: {
  listDebts: jest.fn(),
  upsertDebt: jest.fn(),
  deleteDebt: jest.fn(),
  clearAll: jest.fn(),
  loadDemoData: jest.fn(),
 }
}));

// Mock the debtSync client
jest.mock('../debtSync', () => ({
 debtSyncClient: {
  putAllDebts: jest.fn(),
  mirrorToLocalStorage: jest.fn(),
 }
}));

describe('debtsManager defensive measures', () => {
 beforeEach(() => {
  // Reset manager state before each test
  debtsManager.data = {
   debts: [],
   settings: { extraPayment: 0 },
   projections: null,
   paymentHistory: []
  };
  
  // Clear all mocks
  jest.clearAllMocks();
 });

 describe('getMetrics', () => {
  it('returns default metrics when debts is empty array', () => {
   debtsManager.data.debts = [];
   const metrics = debtsManager.getMetrics();
   
   expect(metrics).toEqual({
    totalDebt: 0,
    totalMinPayments: 0,
    extraPayment: 0
   });
  });

  it('returns default metrics when debts is null', () => {
   debtsManager.data.debts = null;
   const metrics = debtsManager.getMetrics();
   
   expect(metrics).toEqual({
    totalDebt: 0,
    totalMinPayments: 0,
    extraPayment: 0
   });
  });

  it('returns default metrics when debts is undefined', () => {
   debtsManager.data.debts = undefined;
   const metrics = debtsManager.getMetrics();
   
   expect(metrics).toEqual({
    totalDebt: 0,
    totalMinPayments: 0,
    extraPayment: 0
   });
  });

  it('returns default metrics when debts is not an array', () => {
   debtsManager.data.debts = { someDebt: { balance: 1000 } };
   const metrics = debtsManager.getMetrics();
   
   expect(metrics).toEqual({
    totalDebt: 0,
    totalMinPayments: 0,
    extraPayment: 0
   });
  });

  it('calculates metrics correctly with valid debt array', () => {
   debtsManager.data.debts = [
    { balance: 1000, minPayment: 50 },
    { balance: 2000, minPayment: 100 },
    { balance: 0, minPayment: 25 } // Paid off debt
   ];
   debtsManager.data.settings = { extraPayment: 200 };
   
   const metrics = debtsManager.getMetrics();
   
   expect(metrics).toEqual({
    totalDebt: 3000,
    totalMinPayments: 150, // Only active debts (50 + 100)
    extraPayment: 200
   });
  });

  it('handles debts with missing balance/minPayment properties', () => {
   debtsManager.data.debts = [
    { balance: 1000 }, // Missing minPayment
    { minPayment: 50 }, // Missing balance
    { balance: null, minPayment: null },
    { name: 'Invalid Debt' } // No balance or minPayment
   ];
   
   const metrics = debtsManager.getMetrics();
   
   expect(metrics).toEqual({
    totalDebt: 1000,
    totalMinPayments: 50,
    extraPayment: 0
   });
  });
 });

 describe('getDebts defensive measures', () => {
  it('returns empty array when data.debts is null', () => {
   debtsManager.data.debts = null;
   const debts = debtsManager.getDebts();
   
   expect(Array.isArray(debts)).toBe(true);
   expect(debts).toHaveLength(0);
  });

  it('returns empty array when data.debts is undefined', () => {
   debtsManager.data.debts = undefined;
   const debts = debtsManager.getDebts();
   
   expect(Array.isArray(debts)).toBe(true);
   expect(debts).toHaveLength(0);
  });

  it('returns normalized array when data.debts is an object', () => {
   debtsManager.data.debts = {
    debt1: { id: 1, name: 'Test Debt 1' },
    debt2: { id: 2, name: 'Test Debt 2' }
   };
   
   const debts = debtsManager.getDebts();
   
   expect(Array.isArray(debts)).toBe(true);
   expect(debts).toHaveLength(2);
   expect(debts[0]).toEqual({ id: 1, name: 'Test Debt 1' });
   expect(debts[1]).toEqual({ id: 2, name: 'Test Debt 2' });
  });

  it('filters out demo debts when includeDemo is false', () => {
   debtsManager.data.debts = [
    { id: 1, name: 'Real Debt', isDemo: false },
    { id: 2, name: 'Demo Debt', isDemo: true },
    { id: 3, name: 'Another Real Debt' } // No isDemo property
   ];
   
   const debts = debtsManager.getDebts({ includeDemo: false });
   
   expect(debts).toHaveLength(2);
   expect(debts.map(d => d.name)).toEqual(['Real Debt', 'Another Real Debt']);
  });
 });

 describe('error handling in async methods', () => {
  it('handles errors in clearAllData gracefully', async () => {
   const { localDebtStore } = require('../../data/localDebtStore');
   localDebtStore.clearAll.mockRejectedValue(new Error('Storage error'));
   
   // Should not throw, should return empty array
   const result = await debtsManager.clearAllData();
   
   expect(result).toEqual([]);
   expect(debtsManager.data.debts).toEqual([]);
  });

  it('handles errors in loadDemoData gracefully', async () => {
   const { localDebtStore } = require('../../data/localDebtStore');
   localDebtStore.loadDemoData.mockRejectedValue(new Error('Demo load error'));
   
   // Should not crash the app
   await expect(debtsManager.loadDemoData()).rejects.toThrow('Demo load error');
   
   // Manager state should remain stable
   expect(Array.isArray(debtsManager.data.debts)).toBe(true);
  });
 });

 describe('data consistency after operations', () => {
  it('maintains array consistency after clearAllData', async () => {
   const { localDebtStore } = require('../../data/localDebtStore');
   localDebtStore.clearAll.mockResolvedValue(undefined);
   
   await debtsManager.clearAllData();
   
   // Verify all data structures are in expected format
   expect(Array.isArray(debtsManager.data.debts)).toBe(true);
   expect(typeof debtsManager.data.settings).toBe('object');
   expect(Array.isArray(debtsManager.data.paymentHistory)).toBe(true);
   expect(debtsManager.data.projections).toBeNull();
  });

  it('ensures getMetrics never crashes even with corrupted data', () => {
   // Simulate various data corruption scenarios
   const corruptedStates = [
    { debts: 'not an array' },
    { debts: 123 },
    { debts: [{ balance: 'invalid' }] },
    { debts: [null, undefined, {}] },
    { settings: null },
    { settings: { extraPayment: 'invalid' } }
   ];
   
   corruptedStates.forEach((corruptedData, index) => {
    debtsManager.data = { ...debtsManager.data, ...corruptedData };
    
    expect(() => {
     const metrics = debtsManager.getMetrics();
     expect(typeof metrics.totalDebt).toBe('number');
     expect(typeof metrics.totalMinPayments).toBe('number');
     expect(typeof metrics.extraPayment).toBe('number');
    }).not.toThrow(`Failed on corrupted state ${index}`);
   });
  });
 });
});
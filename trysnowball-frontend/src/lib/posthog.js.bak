// Initialize PostHog with lazy loading and privacy-first approach
export const initPostHog = async () => {
 // Check opt-in preference BEFORE loading PostHog
 const analyticsOptIn = localStorage.getItem('analytics_opt_in') === 'true';
 if (!analyticsOptIn) {
  console.log('ðŸ“Š Analytics disabled: user has not opted in');
  return;
 }

 // Lazy load PostHog to reduce initial bundle size
 const { default: posthog } = await import('posthog-js');
 const posthogKey = process.env.REACT_APP_POSTHOG_KEY || 
           process.env.VITE_PUBLIC_POSTHOG_KEY || 
           'phc_TiBCyhgzWEmeR7XdAFMpzAoqZXfeAvVDJwmqiP2Eo7X'; // Fallback for testing
 const posthogHost = process.env.REACT_APP_POSTHOG_HOST || 
           process.env.VITE_PUBLIC_POSTHOG_HOST || 
           'https://eu.posthog.com'; // EU region for GDPR compliance

 if (!posthogKey) {
  console.warn('PostHog API key not found in environment variables');
  return;
 }
 // Check if we should exclude analytics before initializing
 const shouldExcludeAnalytics = () => {
  // Always exclude on localhost
  if (window.location.hostname === 'localhost') {
   console.log('ðŸš« PostHog excluded: localhost detected');
   return true;
  }
  
  // Always exclude in development
  if (process.env.NODE_ENV === 'development') {
   console.log('ðŸš« PostHog excluded: development environment');
   return true;
  }
  
  // Check for development user IDs in localStorage
  const storedUserId = localStorage.getItem('trysnowball-user-id');
  const devUserIds = [
   'dev-user-123',
   '01988524-b5a8-7492-aae0-60f028db3399',
   'user_10d2a63b03e0622b'
  ];
  
  if (devUserIds.includes(storedUserId)) {
   console.log('ðŸš« PostHog excluded: development user ID detected:', storedUserId);
   return true;
  }
  
  // Also check if any context or state has the dev user
  try {
   const contextUser = JSON.parse(localStorage.getItem('user') || '{}');
   if (contextUser.id && devUserIds.includes(contextUser.id)) {
    console.log('ðŸš« PostHog excluded: development user in context:', contextUser.id);
    return true;
   }
  } catch (e) {
   // Ignore JSON parse errors
  }
  
  return false;
 };

 // If we should exclude, don't initialize PostHog at all
 if (shouldExcludeAnalytics()) {
  console.log('ðŸš« PostHog analytics excluded (dev environment)');
  return;
 }

 posthog.init(posthogKey, {
  api_host: posthogHost,
  person_profiles: 'identified_only', // Only create profiles for logged-in users
  autocapture: false, // Disable autocapture for privacy
  capture_pageview: false, // We'll manually track pageviews if needed
  capture_pageleave: false, // Disable automatic page leave tracking
  disable_session_recording: true, // Never record sessions for privacy
  loaded: (posthog) => {
   if (process.env.NODE_ENV === 'development') {
    console.log('âœ… PostHog loaded with privacy settings');
   }
  },
  // Additional exclusion in before_send as backup
  before_send: (event) => {
   const distinctId = posthog.get_distinct_id();
   
   // Exclude specific dev user IDs
   const excludedIds = [
    'dev-user-123',
    '01988524-b5a8-7492-aae0-60f028db3399',
    'user_10d2a63b03e0622b'
   ];
   
   if (excludedIds.includes(distinctId)) {
    if (process.env.NODE_ENV === 'development') {
     console.log('ðŸš« PostHog event blocked for dev user:', distinctId);
    }
    return null; // Don't send event
   }
   
   // Exclude localhost events as backup
   if (window.location.hostname === 'localhost') {
    if (process.env.NODE_ENV === 'development') {
     console.log('ðŸš« PostHog event blocked for localhost');
    }
    return null;
   }
   
   return event;
  },
  // Session recording with privacy controls
  disable_session_recording: process.env.NODE_ENV === 'development',
  session_recording: {
   maskAllInputs: true,
   maskInputOptions: {
    password: true,
    email: true,
    amount: true, // Mask financial data
   }
  },
  capture_pageview: true,
  capture_pageleave: true,
  // Exception capture
  capture_exceptions: true,
  capture_uncaught_exceptions: true,
  capture_promise_rejections: true,
  // Feature flags
  feature_flag_request_timeout: 3000,
  // Advanced tracking
  capture_performance: true,
 });

 // Track the environment and persistent properties
 posthog.register({
  app_version: process.env.REACT_APP_VERSION || '1.0.0',
  environment: process.env.NODE_ENV || 'production',
  user_timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
  screen_resolution: `${window.screen.width}x${window.screen.height}`,
  user_agent: navigator.userAgent,
  platform: navigator.platform
 });

 // Make analytics available globally for convenience
 window.analytics = analytics;
 window._posthogInstance = posthog;
};

// Analytics helper functions
export const analytics = {
 // User identification (when they log in)
 identify: (userId, properties = {}) => {
  // Never identify dev users
  const devUserIds = ['dev-user-123', '01988524-b5a8-7492-aae0-60f028db3399', 'user_10d2a63b03e0622b'];
  if (devUserIds.includes(userId)) {
   console.log('ðŸš« Blocked identification for dev user:', userId);
   return;
  }
  if (window._posthogInstance) {
   window._posthogInstance.identify(userId, properties);
  }
 },

 // Track events
 track: async (eventName, properties = {}) => {
  // Additional safety check - never track dev users even if PostHog was initialized
  const devUserIds = ['dev-user-123', '01988524-b5a8-7492-aae0-60f028db3399', 'user_10d2a63b03e0622b'];
  
  // Lazy load PostHog if not already loaded
  if (!window._posthogInstance) {
   const { default: posthog } = await import('posthog-js');
   window._posthogInstance = posthog;
  }
  
  const posthog = window._posthogInstance;
  if (!posthog) return; // PostHog not loaded yet
  
  const currentUser = properties.user_id || posthog?.get_distinct_id?.();
  
  if (devUserIds.includes(currentUser)) {
   console.log('ðŸš« Blocked tracking event for dev user:', eventName, currentUser);
   return;
  }
  
  if (process.env.NODE_ENV === 'development') {
   console.log('ðŸ“Š [PostHog] Capturing event:', eventName, properties);
  }
  posthog.capture(eventName, properties);
 },

 // Track page views (automatic with capture_pageview: true)
 page: (pageName, properties = {}) => {
  if (window._posthogInstance) {
   window._posthogInstance.capture('$pageview', { 
    page_name: pageName,
    ...properties 
   });
  }
 },

 // Set user properties
 setUserProperties: (properties) => {
  if (window._posthogInstance) {
   window._posthogInstance.people.set(properties);
  }
 },

 // Enhanced user identification with debt context
 identifyWithDebtContext: (userId, debts = [], properties = {}) => {
  if (!window._posthogInstance) return;
  
  const totalDebt = debts.reduce((sum, debt) => sum + (debt.amount_pennies || debt.amount || 0), 0);
  const debtTypes = [...new Set(debts.map(debt => debt.type || 'unknown'))];
  
  window._posthogInstance.identify(userId, {
   ...properties,
   debt_count: debts.length,
   total_debt: totalDebt,
   debt_types: debtTypes,
   debt_level: totalDebt > 10000 ? 'high' : totalDebt > 5000 ? 'medium' : 'low',
   has_debt_data: debts.length > 0
  });

  // Set group for cohort analysis
  if (totalDebt > 0) {
   window._posthogInstance.group('debt_bracket', totalDebt > 10000 ? '10k+' : totalDebt > 5000 ? '5k-10k' : 'under-5k');
  }
 },

 // Feature flag helpers
 getFeatureFlag: (flagName) => {
  return window._posthogInstance?.getFeatureFlag(flagName);
 },

 isFeatureEnabled: (flagName) => {
  return window._posthogInstance?.isFeatureEnabled(flagName);
 },

 // Survey helpers
 getSurveys: () => {
  return window._posthogInstance?.getSurveys();
 },

 // Reset on logout
 reset: () => {
  if (window._posthogInstance) {
   window._posthogInstance.reset();
  }
 }
};

// Debt-specific tracking events
export const debtAnalytics = {
 // When user adds their first debt
 trackFirstDebt: (debtData) => {
  analytics.track('debt_added_first', {
   debt_type: debtData.debt_type || debtData.type || 'unknown',
   amount: debtData.amount || 0,
   interest_rate: debtData.interest_rate,
   min_payment: debtData.min_payment
  });
 },

 // When user adds any debt
 trackDebtAdded: (debtData) => {
  analytics.track('debt_added', {
   debt_type: debtData.debt_type || debtData.type || 'unknown',
   amount: debtData.amount || 0,
   interest_rate: debtData.interest_rate,
   total_debts: debtData.totalCount || 1
  });
 },

 // When user updates debt balance
 trackBalanceUpdate: (oldBalance, newBalance, debtId) => {
  const progressAmount = oldBalance - newBalance;
  analytics.track('debt_balance_updated', {
   debt_id: debtId,
   old_balance: oldBalance,
   new_balance: newBalance,
   progress_amount: progressAmount,
   is_progress: progressAmount > 0
  });
 },

 // When user hits a milestone
 trackMilestone: (milestoneType, debtData = {}) => {
  analytics.track('debt_milestone', {
   milestone_type: milestoneType,
   total_paid_off: debtData.total_paid_off || debtData.amount_paid_off,
   time_to_milestone: debtData.time_to_milestone,
   debt_name: debtData.debt_name,
   debt_type: debtData.debt_type,
   percent_complete: debtData.percent_complete,
   remaining_debt: debtData.remaining_debt,
   debts_remaining: debtData.debts_remaining,
   milestone_amount: debtData.milestone_amount
  });
 },

 // AI Coach usage with enhanced LLM analytics
 trackAICoachMessage: (messageType, context = {}) => {
  analytics.track('ai_coach_message', {
   message_type: messageType,
   user_has_debts: context.hasDebts || false,
   total_debt_amount: context.totalDebt || 0,
   debt_count: context.debtCount || 0,
   journey_state: context.journeyState || 'unknown',
   session_id: context.sessionId || null,
   message_number: context.messageNumber || 1,
   chat_duration_ms: context.chatDurationMs || 0,
   
   // LLM-specific metrics
   llm_response_time_ms: context.responseTimeMs || null,
   llm_input_tokens: context.inputTokens || null,
   llm_output_tokens: context.outputTokens || null,
   llm_total_tokens: context.totalTokens || null,
   llm_model: context.model || 'unknown',
   llm_temperature: context.temperature || null,
   
   // Content analysis
   input_length: context.inputLength || 0,
   output_length: context.outputLength || 0,
   input_word_count: context.inputWordCount || 0,
   output_word_count: context.outputWordCount || 0,
   
   // User engagement
   has_feedback: context.hasFeedback || false,
   feedback_positive: context.feedbackPositive || null,
   
   // Intent classification
   detected_intent: context.detectedIntent || null,
   confidence_score: context.confidenceScore || null,
   
   // Error tracking
   error_type: context.errorType || null,
   error_message: context.errorMessage || null
  });
 },

 // Specific LLM performance tracking
 trackLLMPerformance: (metrics = {}) => {
  analytics.track('llm_performance', {
   model: metrics.model || 'unknown',
   response_time_ms: metrics.responseTimeMs,
   input_tokens: metrics.inputTokens,
   output_tokens: metrics.outputTokens,
   total_tokens: metrics.totalTokens,
   tokens_per_second: metrics.tokensPerSecond,
   cost_estimate: metrics.costEstimate,
   temperature: metrics.temperature,
   max_tokens: metrics.maxTokens,
   finish_reason: metrics.finishReason,
   cached: metrics.cached || false
  });
 },

 // AI conversation flow tracking
 trackConversationFlow: (flowData = {}) => {
  analytics.track('ai_conversation_flow', {
   session_id: flowData.sessionId,
   conversation_length: flowData.conversationLength,
   user_messages: flowData.userMessages,
   ai_messages: flowData.aiMessages,
   conversation_duration_ms: flowData.durationMs,
   topics_discussed: flowData.topics || [],
   actions_taken: flowData.actions || [],
   user_satisfaction: flowData.satisfaction,
   conversation_outcome: flowData.outcome
  });
 },

 // Feature usage
 trackFeatureUsage: (featureName, action = 'used') => {
  analytics.track('feature_usage', {
   feature: featureName,
   action: action
  });
 }
};

export default () => window._posthogInstance;
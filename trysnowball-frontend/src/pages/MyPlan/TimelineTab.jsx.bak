import React, { useState, useMemo, useEffect } from 'react';
import { useSearchParams } from 'react-router-dom';
import NoDebtsState from '../../components/NoDebtsState';
import Button from '../../components/ui/Button';
import { TimelineChart } from '../../components/charts';
import { useCsvExport } from '../../hooks/useCsvExport';
import { useSnowballSettings } from '../../hooks/useSnowballSettings';
import { formatCurrency } from '../../utils/debtFormatting';
import { calculateSnowballTimeline, calculateAvalancheTimeline } from '../../utils/debtTimelineCalculator';
import { calculateBalanceTransferScenarios, mergeBalanceTransferData, getBalanceTransferOfferExamples } from '../../utils/balanceTransferScenarios';
import MathDetails from '../../components/MathDetails';
import EditSnowballModal from '../../components/snowball/EditSnowballModal';
import ImpactHeadline from '../../components/ImpactHeadline';
import { flags } from '../../utils/flags';
import ScenariosPanel from '../../components/ScenariosPanel.jsx';
import { useAnalytics } from '../../hooks/useAnalytics';
import { computeImpacts } from '../../lib/simulator/impact.js';
import DebtPaymentMatrix from '../../components/DebtPaymentMatrix';
import FocusSelect from '../../components/FocusSelect.jsx';
import { getFocusedDebtIdFromSearch, buildDebtBalanceSeries, buildFocusSearchString, getDebtLabelById, getFocusedDebtPayoffDate } from '../../lib/selectors';

// Normalize chart inputs - bulletproof data sanitization
function toNumber(n) {
 const v = typeof n === "string" ? Number(n.replace(/[¬£, ]/g, "")) : Number(n);
 return Number.isFinite(v) ? v : 0;
}

function normalizeSeries(rows) {
 return Array.isArray(rows)
  ? rows
    .map((r, i) => ({
     month: r?.month ?? `Month ${i + 1}`,
     minimumOnly: toNumber(r?.minimumOnly),
     snowball: toNumber(r?.snowball),
    }))
    .filter(r => Number.isFinite(r.minimumOnly) && Number.isFinite(r.snowball))
  : [];
}

const TimelineTab = ({ colors, timelineDebtsData, demoDataCleared, hasNoDebtData, dataManagerDebts: debtsData, planTotalsDebts, planLoading, payoffStrategy = 'snowball', onTabChange }) => {
 const { snowballAmount } = useSnowballSettings();
 const [isEditModalOpen, setIsEditModalOpen] = useState(false);
 // Safe fallback for colors prop
 const safeColors = colors || {
  background: 'bg-gray-50',
  surface: 'bg-white',
  surfaceSecondary: 'bg-gray-50',
  border: 'border-gray-200',
  text: {
   primary: 'text-gray-900',
   secondary: 'text-gray-600',
   muted: 'text-gray-500'
  }
 };
 
 console.log('[TimelineTab] Props received:', {
  hasNoDebtData,
  planTotalsDebts: planTotalsDebts?.length || 0,
  timelineDebtsData: timelineDebtsData?.length || 0,
  planLoading,
  colors: !!colors
 });
 
 const [searchParams, setSearchParams] = useSearchParams();
 const [chartType, setChartType] = useState('line'); // 'line' or 'stacked'
 const [scenarioSelections, setScenarioSelections] = useState([]);
 const [forceShowScenarios, setForceShowScenarios] = useState(false);
 const [scenariosExpanded, setScenariosExpanded] = useState(false);
 const [showBalanceTransferScenarios, setShowBalanceTransferScenarios] = useState(false);
 const [balanceTransferOffers, setBalanceTransferOffers] = useState(getBalanceTransferOfferExamples());
 
 // Analytics
 const { trackEvent } = useAnalytics();
 
 // Focus functionality
 const focusedDebtId = getFocusedDebtIdFromSearch(searchParams.toString());
 
 const handleFocusChange = (debtId) => {
  const newSearch = buildFocusSearchString(searchParams.toString(), debtId);
  setSearchParams(newSearch);
 };
 
 const { exportTimelineData } = useCsvExport();

 // Check for scenario parameter on mount
 useEffect(() => {
  if (searchParams.get('scenario') === 'true') {
   setForceShowScenarios(true);
   setScenariosExpanded(true); // Auto-expand for testing
  }
  
  // Check for balance transfer parameter (from CTA navigation)
  if (searchParams.get('balance_transfer') === 'true') {
   setShowBalanceTransferScenarios(true);
   
   // Track navigation from balance transfer CTA
   trackEvent('balance_transfer_timeline_viewed', {
    source: 'balance_transfer_cta',
    entry_point: 'debts_page'
   });
  }
 }, [searchParams]);

 // Analytics tracking for slider changes (throttled)

 const onScenariosChange = (s) => setScenarioSelections(s);
 
 // Balance Transfer Analytics Handlers
 const handleBalanceTransferToggle = (enabled) => {
  setShowBalanceTransferScenarios(enabled);
  
  trackEvent(enabled ? 'balance_transfer_scenarios_enabled' : 'balance_transfer_scenarios_disabled', {
   source: 'timeline_toggle',
   has_high_apr_debts: timelineDebts?.some(debt => (debt.interest || debt.apr || 0) > 15),
   debt_count: timelineDebts?.length || 0
  });
 };

 // Transform debt data for DebtEngine with order preservation - use same source as other tabs
 const timelineDebts = useMemo(() => {
  console.log('[TimelineTab] Source debts from props:', debtsData?.length, 'debts');
  console.log('[TimelineTab] Demo mode checks:');
  console.log(' - sessionStorage DEMO_IS_ACTIVE:', sessionStorage.getItem('DEMO_IS_ACTIVE'));
  console.log(' - localStorage SNOWBALL_DEMO_FLAG:', localStorage.getItem('SNOWBALL_DEMO_FLAG'));
  console.log(' - sessionStorage DEMO_DEBTS exists:', !!sessionStorage.getItem('DEMO_DEBTS'));
  console.log(' - localStorage keys with "debt":', Object.keys(localStorage).filter(k => k.toLowerCase().includes('debt')));
  console.log(' - Props data has isDemo flags:', debtsData?.some(d => d.isDemo));
  
  let sourceDebts = debtsData || [];
  
  // If props data exists and has isDemo flags, use it directly (IndexedDB demo data)
  if (sourceDebts && sourceDebts.length > 0 && sourceDebts.some(d => d.isDemo)) {
   console.log('[TimelineTab] Using IndexedDB demo data from props:', sourceDebts);
  }
  // Enhanced fallback logic: check multiple data sources if no props data
  else if (!sourceDebts || sourceDebts.length === 0) {
   // Priority 1: sessionStorage demo data
   if (sessionStorage.getItem('DEMO_IS_ACTIVE') === '1') {
    try {
     const demoDebts = JSON.parse(sessionStorage.getItem('DEMO_DEBTS') || '[]');
     if (demoDebts.length > 0) {
      console.log('[TimelineTab] Using sessionStorage demo data:', demoDebts);
      sourceDebts = demoDebts;
     }
    } catch (error) {
     console.warn('[TimelineTab] Failed to parse sessionStorage demo data:', error);
    }
   }
   
   // Priority 2: localStorage demo flag fallback 
   if ((!sourceDebts || sourceDebts.length === 0) && localStorage.getItem('SNOWBALL_DEMO_FLAG') === 'true') {
    try {
     // Look for any localStorage debt data
     const legacyKeys = ['SNOWBALL_DEBTS', 'debts', 'debt_data'];
     for (const key of legacyKeys) {
      const data = localStorage.getItem(key);
      if (data) {
       const parsed = JSON.parse(data);
       if (Array.isArray(parsed) && parsed.length > 0) {
        console.log('[TimelineTab] Using localStorage fallback:', key, parsed);
        sourceDebts = parsed;
        break;
       }
      }
     }
    } catch (error) {
     console.warn('[TimelineTab] Failed to parse localStorage fallback:', error);
    }
   }
  }
  
  if (!Array.isArray(sourceDebts)) {
   console.warn('[TimelineTab] No valid debt data found, returning empty array');
   return [];
  }
  
  const transformed = sourceDebts.map(debt => ({
   id: debt.id || debt.name,
   name: debt.name,
   balance: debt.amount_pennies || debt.amount || 0,
   rate: debt.apr || debt.interest || debt.rate || 20, // Use actual interest rate or default to 20%
   minPayment: debt.min_payment_pennies || debt.min || debt.regularPayment || Math.max(25, Math.floor((debt.amount_pennies || debt.amount || 0) * 0.02)),
   order: debt.order, // Critical: preserve user-defined order
   isDemo: debt.isDemo // Preserve demo flag for debugging
  }));
  
  console.log('[TimelineTab] Final transformed debts:', transformed);
  console.log('[TimelineTab] Total debt amount:', transformed.reduce((sum, d) => sum + d.balance, 0));
  console.log('[TimelineTab] Data source summary:');
  console.log(' - Number of debts:', transformed.length);
  console.log(' - Is demo data:', transformed.some(d => d.isDemo));
  console.log(' - Total balance:', transformed.reduce((sum, d) => sum + d.balance, 0));
  console.log(' - Total min payments:', transformed.reduce((sum, d) => sum + d.minPayment, 0));
  return transformed;
 }, [debtsData]);

 const totalMinPaymentsTimeline = (timelineDebts || []).reduce((sum, debt) => sum + debt.min_payment_pennies, 0);
 const totalDebtTimeline = (timelineDebts || []).reduce((sum, debt) => sum + debt.amount_pennies, 0);

 // Calculate impacts using the new impact system
 const monthsCap = 120;
 const impacts = useMemo(() => {
  if (timelineDebts.length === 0) {
   return { 
    base: null, 
    combined: null, 
    perScenario: [], 
    agg: { monthsSaved: 0, interestSaved: 0 },
    plans: { basePlan: null, combinedPlan: null }
   };
  }
  return computeImpacts(timelineDebts, snowballAmount, scenarioSelections, monthsCap);
 }, [timelineDebts, snowballAmount, scenarioSelections]);

 // Get extra monthly amount from combined plan
 const planExtraMonthly = useMemo(() => {
  if (!impacts.plans.combinedPlan) return snowballAmount;
  return impacts.plans.combinedPlan.extraMonthly;
 }, [impacts, snowballAmount]);

 // Helper function to choose the right calculation method based on strategy
 const calculateTimeline = useMemo(() => {
  return payoffStrategy === 'avalanche' ? calculateAvalancheTimeline : calculateSnowballTimeline;
 }, [payoffStrategy]);

 // Create timeline-based chart data with real dates
 const strategyTimeline = useMemo(() => {
  if (timelineDebts.length === 0) return [];
  
  // Use combined extra payment from impact calculations
  return calculateTimeline(timelineDebts, planExtraMonthly);
 }, [timelineDebts, planExtraMonthly, calculateTimeline]);
 
 const minimumTimeline = useMemo(() => {
  if (timelineDebts.length === 0) return [];
  return calculateTimeline(timelineDebts, 0); // No extra payment for minimum
 }, [timelineDebts, calculateTimeline]);

 // Focus-related calculations (must come after timelineDebts and strategyTimeline are defined)
 const focusedDebtLabel = getDebtLabelById(timelineDebts, focusedDebtId);
 const focusedDebtSeries = buildDebtBalanceSeries(strategyTimeline, focusedDebtId);
 const focusedDebtPayoffDate = getFocusedDebtPayoffDate(strategyTimeline, focusedDebtId);

 // Transform timeline data for payment matrix
 const matrixTimeline = useMemo(() => {
  if (!strategyTimeline || strategyTimeline.length === 0) return [];
  
  return strategyTimeline.map((entry, index) => ({
   monthIndex: index,
   date: entry.date,
   dateLabel: entry.displayDate,
   totalSnowball: entry.totalBalance || 0,
   snowballAmount: planExtraMonthly,
   flex: 0, // Could be used for additional flexible payments
   items: (entry.debts || [])
    .filter(debt => {
     // Only include debts that are in the current timeline debts list
     const timelineDebt = (timelineDebts || []).find(td => td.name === debt.name);
     return timelineDebt && debt.amount_pennies > 0;
    })
    .map(debt => {
     // Find the corresponding timeline debt to get payment info
     const timelineDebt = (timelineDebts || []).find(td => td.name === debt.name);
     return {
      debtId: debt.name,
      label: debt.name,
      payment: timelineDebt?.minPayment || 0, // Use the actual minimum payment
      interest: 0, // Could calculate based on remaining balance
      principal: timelineDebt?.minPayment || 0,
      extra: 0,
      remaining: debt.amount_pennies || 0,
     };
    })
  }));
 }, [strategyTimeline, planExtraMonthly, timelineDebts]);

 // Stable debt column order for payment matrix - use actual user debt labels
 const debtOrder = useMemo(() => {
  return (timelineDebts || []).map(d => d.name).filter(Boolean);
 }, [timelineDebts]);

 // Custom month label function for payment matrix
 const monthLabel = (m) => {
  // prefer existing label if present
  if (m?.dateLabel) return m.dateLabel;
  // else build from current date + monthIndex
  if (Number.isFinite(m?.monthIndex)) {
   const d = new Date();
   d.setMonth(d.getMonth() + m.monthIndex);
   return d.toLocaleString('en-GB', { month: 'short', year: '2-digit' }).replace(' ', '-');
  }
  return `M${(m?.monthIndex ?? 0) + 1}`;
 };
 
 const chartData = useMemo(() => {
  const maxLength = Math.max(strategyTimeline.length, minimumTimeline.length);
  const data = [];
  
  for (let i = 0; i < maxLength; i++) {
   const strategyEntry = strategyTimeline[i];
   const minimumEntry = minimumTimeline[i];
   
   data.push({
    month: strategyEntry?.displayDate || minimumEntry?.displayDate || `Month ${i + 1}`,
    minimumOnly: minimumEntry?.totalBalance || 0,
    snowball: strategyEntry?.totalBalance || 0, // Keep 'snowball' key for chart compatibility
   });
  }
  
  console.log('[TimelineTab] Chart data:', {
   dataLength: data.length,
   planExtraMonthly,
   firstPoint: data[0],
   lastPoint: data[data.length - 1]
  });
  return data;
 }, [strategyTimeline, minimumTimeline, planExtraMonthly]);

 // Create stacked chart data showing individual debt balances over time
 const stackedChartData = useMemo(() => {
  if (chartType !== 'stacked') return [];
  
  const sortedDebts = [...timelineDebts].sort((a, b) => a.balance - b.balance);
  const colors = ['#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#06b6d4', '#84cc16', '#f97316'];
  
  // Create a simulation specifically for stacked view
  const stackedSimulation = () => {
   const debtBalances = sortedDebts.map(debt => ({
    name: debt.name,
    balance: debt.amount_pennies,
    rate: debt.rate,
    minPayment: debt.min_payment_pennies,
    color: colors[sortedDebts.indexOf(debt) % colors.length]
   }));
   
   const monthlyData = [];
   
   for (let month = 0; month < 61; month++) {
    const monthData = { month };
    
    // Add each debt's balance for this month
    debtBalances.forEach(debt => {
     monthData[debt.name] = Math.max(0, debt.amount_pennies);
    });
    
    monthlyData.push(monthData);
    
    // Apply snowball method for next month
    if (month < 60) {
     let totalPayment = totalMinPaymentsTimeline + snowballAmount;
     
     // Pay minimums first
     debtBalances.forEach(debt => {
      if (debt.amount_pennies > 0) {
       const interest = debt.amount_pennies * (debt.rate / 12 / 100);
       const principal = Math.max(0, debt.min_payment_pennies - interest);
       debt.amount_pennies = Math.max(0, debt.amount_pennies - principal);
       totalPayment -= debt.min_payment_pennies;
      }
     });
     
     // Apply extra payment to smallest debt
     if (totalPayment > 0) {
      for (let debt of debtBalances) {
       if (debt.amount_pennies > 0) {
        const payment = Math.min(totalPayment, debt.amount_pennies);
        debt.amount_pennies -= payment;
        break;
       }
      }
     }
    }
   }
   
   return { monthlyData, debtInfo: debtBalances };
  };
  
  const { monthlyData, debtInfo } = stackedSimulation();
  return { data: monthlyData, debtInfo };
 }, [timelineDebts, snowballAmount, totalMinPaymentsTimeline, chartType]);

 // Ensure both datasets exist for the selected view
 const lineData = useMemo(() => {
  return normalizeSeries(chartData);
 }, [chartData]);

 const stackedData = useMemo(() => {
  // stackedChartData is either [] (when not stacked) or { data: [...], debtInfo: [...] } (when stacked)
  const d = Array.isArray(stackedChartData) ? [] : (stackedChartData?.data ?? []);
  console.log('[TimelineTab] Stacked raw data:', d?.length, 'entries, sample:', d[0]);
  // coerce every key to a number except 'month'
  const normalized = Array.isArray(d)
   ? d.map(row =>
     Object.fromEntries(
      Object.entries(row).map(([k, v]) => [k, k === "month" ? row.month : toNumber(v)])
     )
    )
   : [];
  console.log('[TimelineTab] Stacked normalized:', normalized?.length, 'entries, sample:', normalized[0]);
  return normalized;
 }, [stackedChartData]);

 const hasLine = lineData.length > 0 && lineData.some(r => r.minimumOnly > 0 || r.snowball > 0);
 const hasStacked = stackedData.length > 0 && Object.keys(stackedData[0] || {}).length > 1;
 
 // Balance Transfer Scenario Calculations
 const balanceTransferScenarios = useMemo(() => {
  if (!showBalanceTransferScenarios || !timelineDebts || timelineDebts.length === 0) {
   return null;
  }
  
  // Find high APR debts (>15%) that could benefit from balance transfers
  const highAPRDebts = timelineDebts.filter(debt => {
   const apr = debt.interest || debt.apr || 0;
   return apr > 15 && (debt.amount_pennies || debt.amount || 0) > 1000;
  });
  
  if (highAPRDebts.length === 0) {
   return null;
  }
  
  // Calculate scenarios with default monthly payment capacity
  const monthlyPaymentCapacity = Math.max(snowballAmount + 50, 200); // Assume user can pay extra + 50 minimum
  
  const scenarios = calculateBalanceTransferScenarios({
   debts: highAPRDebts,
   monthlyPaymentCapacity,
   optionA: balanceTransferOffers.optionA,
   optionB: balanceTransferOffers.optionB
  });
  
  // Track scenario calculation
  if (scenarios) {
   trackEvent('balance_transfer_scenarios_calculated', {
    high_apr_debts_count: highAPRDebts.length,
    total_high_apr_debt: highAPRDebts.reduce((sum, debt) => sum + (debt.amount_pennies || debt.amount || 0), 0),
    monthly_payment_capacity: monthlyPaymentCapacity,
    has_option_a: !!scenarios.optionA,
    has_option_b: !!scenarios.optionB,
    promo_end_month: scenarios.promoEndMonth
   });
  }
  
  return scenarios;
 }, [showBalanceTransferScenarios, timelineDebts, snowballAmount, balanceTransferOffers, trackEvent]);
 
 // Enhanced line data with balance transfer scenarios
 const enhancedLineData = useMemo(() => {
  if (!balanceTransferScenarios) {
   return lineData;
  }
  
  return mergeBalanceTransferData(lineData, balanceTransferScenarios);
 }, [lineData, balanceTransferScenarios]);
 
 console.log('[TimelineTab] Chart state:', {
  chartType,
  hasLine,
  hasStacked,
  stackedDataLength: stackedData.length,
  debtInfoLength: stackedChartData?.debtInfo?.length || 0
 });

 // Calculate payoff months from line data
 const strategyPayoffMonths = lineData.findIndex((p, index) => index > 0 && p.snowball <= 1);
 const minimumPayoffMonths = lineData.findIndex((p, index) => index > 0 && p.minimumOnly <= 1);
 
 // Calculate interest paid (simplified calculation)
 const strategyInterestPaid = strategyPayoffMonths > 0 ? strategyPayoffMonths * 100 : 0;
 const minimumInterestPaid = minimumPayoffMonths > 0 ? minimumPayoffMonths * 150 : 0;

 // Calculate deltas for scenario display
 const monthsSaved = Math.max(0, minimumPayoffMonths - strategyPayoffMonths);
 const interestSaved = Math.max(0, minimumInterestPaid - strategyInterestPaid);
 
 // Check if user has any active scenarios
 const hasActiveScenarios = scenarioSelections.some(s => s.active);
 
 // Temporarily show headline even without scenarios if there's improvement from slider
 const hasSliderImpact = snowballAmount > 0 && (monthsSaved > 0 || interestSaved > 0);
 const showImpactHeadline = (hasActiveScenarios && (impacts.agg.monthsSaved > 0 || impacts.agg.interestSaved > 0)) || 
              (!hasActiveScenarios && hasSliderImpact);
 
 console.log('[TimelineTab] Impact headline debug:', {
  hasActiveScenarios,
  hasSliderImpact,
  monthsSaved: impacts.agg.monthsSaved,
  interestSaved: impacts.agg.interestSaved,
  sliderMonthsSaved: monthsSaved,
  sliderInterestSaved: interestSaved,
  snowballAmount,
  showImpactHeadline
 });

 if (hasNoDebtData) {
  return (
   <NoDebtsState 
    title="No Forecast Yet"
    subtitle="Add your debts to see your personalised debt-free date and repayment timeline."
    icon="üìÖ"
   />
  );
 }

 return (
  <div className="space-y-6">
   <div className="flex items-center justify-between">
    <div>
     <h2 className={`text-xl font-semibold ${safeColors.text.primary}`}>Your Path to Debt Freedom</h2>
     <p className={`text-sm ${safeColors.text.muted} mt-1`}>Based on your debts and payments today</p>
    </div>
   </div>

   {/* Snowball Slider & Impact - 50/50 Layout */}
   <div className="grid grid-cols-1 lg:grid-cols-2 gap-4 items-stretch">
    {/* Unified Snowball Amount Display */}
    <div className="h-full rounded-2xl border bg-white p-4 flex flex-col">
     <label className="text-sm font-medium text-gray-700">
      Snowball Amount
     </label>
     
     <div className="mt-2 mb-2">
      <span className="text-2xl font-bold text-green-600">¬£{snowballAmount}</span>
      <span className="text-sm text-gray-500 ml-1">/month</span>
     </div>
     
     <button
      onClick={() => setIsEditModalOpen(true)}
      className="w-full mt-auto bg-primary text-white py-2 px-4 rounded-lg hover:bg-primary/90 transition-colors"
     >
      Edit Amount
     </button>
     
     <p className="text-xs text-gray-500 mt-2">
      Add extra each month to speed up your debt freedom journey.
     </p>
    </div>
    <ImpactHeadline 
     impact={{
      monthsSaved: hasActiveScenarios ? impacts.agg.monthsSaved : monthsSaved,
      interestSaved: hasActiveScenarios ? impacts.agg.interestSaved : interestSaved
     }}
     basePayoffMonths={minimumPayoffMonths}
     strategyPayoffMonths={strategyPayoffMonths}
    />
   </div>

   {/* Centered Snowflake CTA underneath both boxes */}
   <div className="flex flex-col items-center space-y-2">
    <button
     onClick={() => onTabChange && onTabChange('snowflakes')}
     className="inline-flex items-center gap-1.5 px-4 py-2 text-sm font-medium text-white bg-green-600 rounded-lg hover:bg-green-700 transition-colors"
    >
     <span>Log a Snowflake</span>
     <span>‚ùÑÔ∏è</span>
    </button>
    <p className="text-xs text-gray-500 text-center">
     üí° One-off payments give your plan an instant boost.
    </p>
   </div>

   {/* Core Numbers - Subdued */}
   <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
    <div className="p-4 rounded-lg bg-slate-50 border border-slate-200">
     <div className="text-2xl font-bold text-slate-800">{formatCurrency(totalDebtTimeline)}</div>
     <div className="text-sm text-slate-600">Total Balance</div>
    </div>
    <div className="p-4 rounded-lg bg-slate-50 border border-slate-200">
     <div className="text-2xl font-bold text-slate-800">{formatCurrency(totalMinPaymentsTimeline)}</div>
     <div className="text-sm text-slate-600">Monthly Minimums</div>
    </div>
    <div className="p-4 rounded-lg bg-slate-50 border border-slate-200">
     <div className="text-2xl font-bold text-slate-800">{formatCurrency(totalMinPaymentsTimeline + planExtraMonthly)}</div>
     <div className="text-sm text-slate-600">Your Payment Each Month</div>
    </div>
   </div>


   {/* Expandable Scenarios Panel */}
   {(flags.SCENARIOS || forceShowScenarios) && (
    <div className="bg-white border border-slate-200 rounded-lg">
     <button
      onClick={() => setScenariosExpanded(!scenariosExpanded)}
      className="w-full p-4 flex items-center justify-between hover:bg-slate-50 transition-colors"
     >
      <div className="flex items-center gap-2">
       <span className="text-lg">üí°</span>
       <span className="font-medium text-slate-700">Explore lifestyle boosts</span>
      </div>
      <div className="flex items-center gap-2">
       {hasActiveScenarios && !scenariosExpanded && (
        <span className="text-sm text-emerald-600 font-medium">
         {scenarioSelections.filter(s => s.active).length} active scenarios
        </span>
       )}
       <svg 
        className={`w-5 h-5 text-slate-500 transition-transform ${scenariosExpanded ? 'rotate-180' : ''}`}
        fill="none" 
        stroke="currentColor" 
        viewBox="0 0 24 24"
       >
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
       </svg>
      </div>
     </button>
     {scenariosExpanded && (
      <div className="px-4 pb-4">
       <ScenariosPanel onChange={onScenariosChange} impacts={impacts.perScenario} />
      </div>
     )}
    </div>
   )}

   {/* Chart Section - More Breathing Room */}
   <div className="space-y-6 py-4">
    {/* Focus Control */}
    {timelineDebts.length > 0 && (
     <FocusSelect 
      debts={timelineDebts} 
      focusedDebtId={focusedDebtId} 
      onChange={handleFocusChange}
     />
    )}
    
    {/* Focused Debt Badge */}
    {focusedDebtId && focusedDebtLabel && (
     <div className={`inline-flex items-center space-x-2 px-4 py-2 rounded-lg ${safeColors.surfaceSecondary} border ${safeColors.border}`}>
      <span className={`text-sm font-medium ${safeColors.text.primary}`}>
       Focused on: {focusedDebtLabel}
      </span>
      {focusedDebtPayoffDate && (
       <span className={`text-sm ${safeColors.text.muted}`}>
        Payoff by {focusedDebtPayoffDate.toLocaleDateString('en-GB', { month: 'short', year: 'numeric' })}
       </span>
      )}
      <button
       onClick={() => handleFocusChange(null)}
       className={`text-sm px-2 py-1 rounded ${safeColors.text.muted} hover:${safeColors.text.secondary}`}
      >
       √ó
      </button>
     </div>
    )}

    {/* Chart Controls */}
    <div className="flex justify-between items-center">
     {/* Chart Type Toggle */}
     <div className="bg-gray-100 p-1 rounded-lg">
      <Button
       onClick={() => setChartType('line')}
       variant={chartType === 'line' ? 'muted' : 'ghost'}
       size="sm"
       className={chartType === 'line' ? 'bg-white text-blue-600 shadow-sm' : 'text-gray-600 hover:text-gray-900'}
      >
       Line View
      </Button>
      <Button
       onClick={() => setChartType('stacked')}
       variant={chartType === 'stacked' ? 'muted' : 'ghost'}
       size="sm"
       className={chartType === 'stacked' ? 'bg-white text-blue-600 shadow-sm' : 'text-gray-600 hover:text-gray-900'}
      >
       Stacked View
      </Button>
     </div>
     
     {/* Balance Transfer Scenarios Toggle */}
     {chartType === 'line' && (
      <div className="bg-gray-100 p-1 rounded-lg">
       <Button
        onClick={() => handleBalanceTransferToggle(!showBalanceTransferScenarios)}
        variant={showBalanceTransferScenarios ? 'muted' : 'ghost'}
        size="sm"
        className={showBalanceTransferScenarios ? 'bg-white text-purple-600 shadow-sm' : 'text-gray-600 hover:text-gray-900'}
       >
        Balance Transfer
       </Button>
      </div>
     )}
     
     {/* Export Buttons */}
     <div className="flex items-center space-x-2">
      <Button
       onClick={() => exportTimelineData(strategyTimeline)}
       variant="ghost"
       size="sm"
       className="text-gray-600 hover:text-gray-900"
      >
       üìä Export as CSV
      </Button>
     </div>
    </div>

    {/* Chart - Guarded Rendering with Increased Height */}
    {!hasLine && chartType === "line" && (
     <div className="p-8 text-center text-sm text-slate-600 border rounded bg-gray-50">
      üìä Add debts or load demo data to see your forecast.
     </div>
    )}
    {chartType === "line" && hasLine && (
     <div className="bg-white border border-slate-200 rounded-lg p-4">
      <TimelineChart 
       chartData={enhancedLineData}
       stackedChartData={null}
       chartType="line"
       height={500}
       focusedDebtSeries={focusedDebtId ? focusedDebtSeries : null}
       focusedDebtLabel={focusedDebtLabel}
       balanceTransferScenarios={balanceTransferScenarios}
      />
      
      {/* Balance Transfer Scenarios Legend */}
      {showBalanceTransferScenarios && balanceTransferScenarios && (
       <div className="mt-4 p-3 bg-blue-50 border border-blue-200 rounded-lg">
        <h4 className="font-semibold text-sm text-blue-800 mb-2">Balance Transfer Scenarios</h4>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-3 text-sm">
         {balanceTransferScenarios.optionA && (
          <div className="flex items-center space-x-2">
           <div className="w-4 h-0.5 bg-blue-600" style={{borderStyle: 'dashed', borderWidth: '1px 0'}}></div>
           <span className="text-gray-700">
            <span className="font-medium">0% Transfer:</span> 3% fee, then 24.9% APR
           </span>
          </div>
         )}
         {balanceTransferScenarios.optionB && (
          <div className="flex items-center space-x-2">
           <div className="w-4 h-0.5 bg-purple-600" style={{borderStyle: 'dotted', borderWidth: '1px 0'}}></div>
           <span className="text-gray-700">
            <span className="font-medium">Low APR:</span> 8.9% APR, no fee
           </span>
          </div>
         )}
        </div>
        {balanceTransferScenarios.promoEndMonth && (
         <div className="mt-2 text-xs text-gray-600">
          <span className="text-red-600">‚ñ†</span> Red line shows when 0% promotion ends (Month {balanceTransferScenarios.promoEndMonth})
         </div>
        )}
       </div>
      )}
     </div>
    )}

    {chartType === "stacked" && !hasStacked && (
     <div className="p-8 text-center text-sm text-slate-600 border rounded bg-gray-50">
      üìä Not enough data for stacked view yet ‚Äî switch to Line view.
     </div>
    )}
    {chartType === "stacked" && hasStacked && (
     <div className="bg-white border border-slate-200 rounded-lg p-4">
      <TimelineChart 
       chartData={null}
       stackedChartData={{ 
        data: stackedData,
        debtInfo: stackedChartData?.debtInfo || []
       }}
       chartType="stacked"
       height={500}
      />
     </div>
    )}
   </div>

   {/* Results Summary */}
   <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
    {/* Minimum Payments */}
    <div className="bg-yellow-50 border-l-4 border-yellow-500 rounded-lg p-6">
     <div className="flex items-center mb-3">
      <div className="bg-yellow-100 rounded-full p-2 mr-3">
       <svg className="w-6 h-6 text-yellow-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
       </svg>
      </div>
      <h3 className="text-lg font-bold text-yellow-800">Minimum Payments Only</h3>
     </div>
     <p className="text-xl font-bold text-yellow-600 mb-1">
      {minimumPayoffMonths > 0 ? minimumPayoffMonths : 'Never'} {minimumPayoffMonths > 0 ? 'months' : ''}
     </p>
     <p className="text-sm text-yellow-700">to be debt-free</p>
     <p className="text-xs text-yellow-600 mt-2">
      {formatCurrency(minimumInterestPaid)} interest paid
     </p>
    </div>

    {/* Strategy Method */}
    <div className="bg-green-50 border-l-4 border-green-500 rounded-lg p-6">
     <div className="flex items-center mb-3">
      <div className="bg-green-100 rounded-full p-2 mr-3">
       <svg className="w-6 h-6 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6" />
       </svg>
      </div>
      <h3 className="text-lg font-bold text-green-800">{payoffStrategy === 'avalanche' ? 'Avalanche' : 'Snowball'} Strategy</h3>
     </div>
     <p className="text-xl font-bold text-green-600 mb-1">
      {strategyPayoffMonths > 0 ? strategyPayoffMonths : 'Never'} {strategyPayoffMonths > 0 ? 'months' : ''}
     </p>
     <p className="text-sm text-green-700">to be debt-free</p>
     <p className="text-xs text-green-600 mt-2">
      {formatCurrency(strategyInterestPaid)} interest paid
     </p>
    </div>
   </div>

   {/* Impact Summary */}
   {strategyPayoffMonths > 0 && minimumPayoffMonths > 0 && (
    <div className={`rounded-lg shadow-lg p-6 ${safeColors.surface}`}>
     <h3 className={`text-xl font-bold ${safeColors.text.primary} mb-4`}>Why It Matters</h3>
     <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
      <div className="text-center p-4 bg-green-50 rounded-lg">
       <p className="text-sm text-gray-600 mb-1">Save</p>
       <p className="text-3xl font-bold text-green-600">
        ¬£{Math.max(0, minimumInterestPaid - strategyInterestPaid).toLocaleString()}
       </p>
       <p className="text-sm text-gray-600">in interest</p>
      </div>
      <div className="text-center p-4 bg-blue-50 rounded-lg">
       <p className="text-sm text-gray-600 mb-1">Be debt-free</p>
       <p className="text-3xl font-bold text-blue-600">
        {Math.max(0, minimumPayoffMonths - strategyPayoffMonths)}
       </p>
       <p className="text-sm text-gray-600">months sooner</p>
      </div>
     </div>
    </div>
   )}

   {/* Math Details - Trust-building payoff table */}
   <MathDetails snowballAmount={snowballAmount} />

   {/* Payment Matrix - Detailed month-by-month schedule */}
   <DebtPaymentMatrix
    timeline={matrixTimeline}
    debtOrder={debtOrder}
    monthLabel={monthLabel}
    defaultOpen={false}
    focusedDebtId={focusedDebtId}
   />

   {/* Edit Snowball Modal */}
   <EditSnowballModal
    isOpen={isEditModalOpen}
    onClose={() => setIsEditModalOpen(false)}
   />
  </div>
 );
};

export default TimelineTab;
import React, { useState, useMemo } from 'react';
import { useNavigate } from 'react-router-dom';
import { useUserDebts } from '../../hooks/useUserDebts';
import { toCents } from '../../lib/money';
// Removed adapter import - using clean UK format directly
import { computeDebtTotals } from '../../selectors/debtTotals';
import { getHighAprDebts } from '../../selectors/debtRates';
// Note: updateDebtPartial helper available but not yet integrated with useUserDebts
// import { updateDebtPartial } from '../../utils/debtUpdates';

// Import the sophisticated debt management components
import DebtSummaryCards from '../../components/debt/DebtSummaryCards';
import DebtTable from '../../components/debt/DebtTable';
import DebtFormModal from '../../components/debt/DebtFormModal';
import DebtHistoryViewer from '../../components/DebtHistoryViewer';
import SimpleToast from '../../components/SimpleToast';
import NoDebtsState from '../../components/NoDebtsState';
import BalanceTransferCTA from '../../components/BalanceTransferCTA';
import { FLAGS } from '../../config/flags';

// Conditional import for development/testing
let HistoryImporterModal = null;
if (FLAGS.IMPORT_HISTORY_ENABLED) {
 // Dynamic import will be handled at component level
}

const DebtsTab = ({ loading }) => {
 const navigate = useNavigate();
 
 // Use encrypted user debts API
 const { 
  debts,
  loading: debtsLoading,
  upsertDebt
 } = useUserDebts();
 
 const [showAddModal, setShowAddModal] = useState(false);
 const [editingDebt, setEditingDebt] = useState(null);
 
 // console.log('DEBUG DebtsTab state:', { showAddModal, editingDebt: !!editingDebt, debtsCount: debts?.length });
 const [historyDebt, setHistoryDebt] = useState(null);
 const [toast, setToast] = useState(null);
 
 // Import functionality state (flag-guarded)
 const [showHistoryImporter, setShowHistoryImporter] = useState(false);
 const [importingDebt, setImportingDebt] = useState(null);

 // Use debts directly - already in clean UK format
 const viewDebts = useMemo(() => {
  return debts;
 }, [debts]);

 // Compute all debt totals using selector
 const debtTotals = useMemo(() => computeDebtTotals(debts), [debts]);

 // Balance Transfer Detection Logic using selector
 const balanceTransferContext = useMemo(() => {
  const highAPRDebts = getHighAprDebts(debts, 15);
  
  if (highAPRDebts.length === 0) {
   return null; // No high APR debts, don't show CTA
  }
  
  const totalHighAPRDebt = highAPRDebts.reduce((sum, debt) => sum + debt.amount_pennies, 0);
  const averageAPR = highAPRDebts.reduce((sum, debt, _, arr) => {
   const apr = debt.apr;
   return sum + (apr / arr.length);
  }, 0);
  
  return {
   highAPRDebts,
   totalDebt: totalHighAPRDebt,
   averageAPR,
   shouldShow: highAPRDebts.length > 0 && totalHighAPRDebt > 100000 // Only show if meaningful amount (¬£1000+ in pence)
  };
 }, [debts]);

 // Event handlers
 const handleAddDebt = () => {
  setEditingDebt(null);
  setShowAddModal(true);
 };
 
 const handleOpenBalanceTransferCoach = ({ mode, context }) => {
  // Navigate to coach with balance transfer context
  navigate('/coach', { 
   state: { 
    mode,
    context 
   }
  });
 };

 const handleEditDebt = (debt) => {
  setEditingDebt(debt);
  setShowAddModal(true);
 };

 const handleDeleteDebt = async (debtId) => {
  if (window.confirm('Are you sure you want to delete this debt?')) {
   try {
    // Mark debt as deleted - only send normalized fields
    await upsertDebt({ 
     id: debtId, 
     deleted: true, 
     amount_pennies: 0 
    });
    showToast('Debt deleted successfully', 'success');
   } catch (error) {
    showToast('Failed to delete debt', 'error');
   }
  }
 };

 const handleInlineBalanceUpdate = async (debtId, newBalance) => {
  try {
   // Convert newBalance (pounds) to cents for storage - only send what changed
   const newBalanceCents = toCents(newBalance);
   
   // Update only the balance - no spreading of existing debt to prevent legacy field leakage
   await upsertDebt({ 
    id: debtId,
    amount_pennies: newBalanceCents 
   });
   showToast('Balance updated successfully', 'success');
  } catch (error) {
   showToast('Failed to update balance', 'error');
  }
 };

 const handleViewHistory = FLAGS.IMPORT_HISTORY_ENABLED ? (debt) => {
  // Open the history importer modal instead of viewer
  setImportingDebt(debt);
  setShowHistoryImporter(true);
 } : undefined;

 const handleImportComplete = FLAGS.IMPORT_HISTORY_ENABLED ? (count) => {
  setShowHistoryImporter(false);
  setImportingDebt(null);
  showToast(`Successfully imported ${count} historical snapshots`, 'success');
  // Data will auto-refresh through useUserDebts
 } : undefined;

 const handleReorderDebts = async (orderUpdates) => {
  try {
   // Update each debt's order via upsertDebt - only send normalized fields
   for (const update of orderUpdates) {
    await upsertDebt({ 
     id: update.id, 
     order_index: update.order 
    });
   }
   showToast('Debt order updated', 'success');
  } catch (error) {
   showToast('Failed to reorder debts', 'error');
  }
 };

 const handleSaveDebt = async (debtData) => {
  try {
   console.log('üîß [SAVE_DEBT] Raw form data:', debtData);
   
   // Check for undefined values in incoming data
   Object.entries(debtData).forEach(([key, value]) => {
    if (value === undefined) {
     console.error(`üö® [SAVE_DEBT] UNDEFINED IN FORM DATA: ${key} = ${value}`);
    }
   });
   
   // Simple passthrough - expect form to send correct field names  
   const normalizedData = {
    id: editingDebt ? editingDebt.id : Date.now().toString(),
    name: debtData.name,
    debt_type: debtData.debt_type,
    amount: debtData.amount,
    original_amount: debtData.original_amount || debtData.amount,
    apr: debtData.apr,
    min_payment: debtData.min_payment,
    created_at: debtData.created_at || new Date().toISOString(),
    updated_at: new Date().toISOString(),
    order_index: debtData.order_index || 0,
    is_demo: debtData.is_demo,
    notes: debtData.notes,
    account_number: debtData.account_number,
    due_date: debtData.due_date,
    limit: debtData.limit
   };
   
   console.log('üîß [SAVE_DEBT] Final data before upsert:', normalizedData);
   
   // Check for undefined values in final data
   Object.entries(normalizedData).forEach(([key, value]) => {
    if (value === undefined) {
     console.error(`üö® [SAVE_DEBT] UNDEFINED IN FINAL DATA: ${key} = ${value}`);
    }
   });
   
   await upsertDebt(normalizedData);
   showToast(editingDebt ? 'Debt updated successfully' : 'Debt added successfully', 'success');
   setShowAddModal(false);
   setEditingDebt(null);
  } catch (err) {
   console.error('Failed to save debt', err);
   showToast('Could not save debt', 'error');
  }
 };

 const showToast = (message, type) => {
  setToast({ message, type });
  setTimeout(() => setToast(null), 3000);
 };

 if (loading || debtsLoading) {
  return (
   <div className="flex items-center justify-center py-12">
    <div className="text-center">
     <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-4"></div>
     <p className="text-slate-600">Loading your debts...</p>
    </div>
   </div>
  );
 }

 // Empty state guard
 if (!loading && !debtsLoading && debts.length === 0) {
  return (
   <NoDebtsState
    title="No debts yet"
    subtitle="Add your first debt to start tracking your progress."
    icon="üí≥"
    showSecondaryActions={false}
    onAdd={() => setShowAddModal(true)}
   />
  );
 }

 // Debug logging
 if (process.env.NODE_ENV === 'development') {
  // console.log('üîç DebtsTab Debug:', {
  //  debtsLength: debts.length,
  //  debtsData: debts,
  //  totalDebt,
  //  totalMinPayments,
  //  creditUtilization,
  //  loading,
  //  debtsLoading,
  //  isAuthenticated,
  //  error: debtsError
  // });
 }

 return (
  <div className="space-y-6">
   
   {/* Summary Cards - only show if debts exist */}
   {debts.length > 0 && (
    <DebtSummaryCards 
     totalDebt={debtTotals.totalDebt} 
     totalMinPayments={debtTotals.totalMinPayments} 
     creditUtilization={debtTotals.creditUtilization}
     loading={debtsLoading}
    />
   )}
   
   {/* Balance Transfer CTA - show if high APR debts detected */}
   {balanceTransferContext?.shouldShow && (
    <BalanceTransferCTA
     context={balanceTransferContext}
     onOpenCoach={handleOpenBalanceTransferCoach}
     onDismiss={() => {
      // CTA will handle its own dismiss state management
     }}
    />
   )}

   {/* Debt Table with Card Wrapper */}
   <div className="bg-white rounded-lg shadow-sm border border-slate-200 overflow-hidden">
    <DebtTable 
     debts={viewDebts}
     onEdit={handleEditDebt}
     onDelete={handleDeleteDebt}
     onBalanceUpdate={handleInlineBalanceUpdate}
     onViewHistory={FLAGS.IMPORT_HISTORY_ENABLED ? handleViewHistory : undefined}
     onReorder={handleReorderDebts}
     onAddDebt={handleAddDebt}
    />
   </div>

   {/* Add/Edit Debt Modal */}
   {showAddModal && (
    <DebtFormModal
     isOpen={showAddModal}
     editingDebt={editingDebt}
     onSave={handleSaveDebt}
     onClose={() => {
      setShowAddModal(false);
      setEditingDebt(null);
     }}
     loading={false}
    />
   )}

   {/* Debt History Viewer */}
   {historyDebt && (
    <DebtHistoryViewer 
     debt={historyDebt}
     onClose={() => setHistoryDebt(null)}
    />
   )}

   {/* History Importer Modal */}
   {FLAGS.IMPORT_HISTORY_ENABLED && showHistoryImporter && importingDebt && HistoryImporterModal && (
    <HistoryImporterModal
     debt={importingDebt}
     isOpen={showHistoryImporter}
     onClose={() => {
      setShowHistoryImporter(false);
      setImportingDebt(null);
     }}
     onImportComplete={handleImportComplete}
    />
   )}

   {/* Toast Notifications */}
   {toast && (
    <SimpleToast
     message={toast.message}
     type={toast.type}
     onClose={() => setToast(null)}
    />
   )}
  </div>
 );
};

export default DebtsTab;
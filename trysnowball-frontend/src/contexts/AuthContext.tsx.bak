import React, { createContext, useContext, useState, useEffect } from 'react';
import { getToken } from '../utils/tokenStorage';
import { IS_PREVIEW } from '../utils/env';
import { fetchLocalUser, fetchLocalEntitlement } from '../lib/authLocal';

// Auth mode: 'cloudflare' for real auth, 'local' for bypass
type AuthMode = 'cloudflare' | 'local';
const MODE = process.env.REACT_APP_AUTH_MODE?.toLowerCase();
const AUTH_MODE: AuthMode =
 MODE === 'cloudflare' || MODE === 'local'
  ? MODE
  : (process.env.NODE_ENV === 'production' ? 'cloudflare' : 'local'); // default: prodâ†’cloudflare, devâ†’local

interface User {
 id: string;
 email: string;
 name?: string;
 isPro?: boolean;
 hasUsedTrial?: boolean;
 trialEndsAt?: string;
 trialStatus?: string;
 plan?: 'free' | 'beta' | 'pro';
}

interface Entitlement {
 isPro: boolean;
 plan?: 'pro' | 'free';
 betaAccess?: boolean;
 dailyQuota?: number;
}

interface AuthContextType {
 authReady: boolean;
 user: User | null;
 isAuthed: boolean;
 isAuthenticated: boolean; // Alias for isAuthed
 isPro: boolean; // Computed helper
 plan: 'free' | 'beta' | 'pro';
 token: string | null;
 entitlement: Entitlement;
 logout: () => Promise<void>;
 refreshAuth: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType>({
 authReady: false,
 user: null,
 isAuthed: false,
 isAuthenticated: false,
 isPro: false,
 plan: 'free',
 token: null,
 entitlement: { isPro: false, plan: 'free' },
 logout: async () => {},
 refreshAuth: async () => {},
});

// API base URL for dev proxy
const API_BASE = process.env.REACT_APP_API_BASE ?? '';
const api = (path: string, init?: RequestInit) =>
 fetch(`${API_BASE}${path}`, { credentials: 'include', ...init });

// Fallback helper with prod logging
function fallbackToFree(reason: string, context: string) {
 if (process.env.NODE_ENV === 'production') {
  console.warn(`[auth] falling back to free (${context}):`, reason);
  // TODO: track('auth_fallback_free', { reason, context });
 }
 return { isPro: false, plan: 'free' as const };
}

// Fetcher functions with safe fallbacks
async function fetchMe(): Promise<{ user: User | null }> {
 if (AUTH_MODE !== 'cloudflare') return { user: null };
 
 try {
  const user = await fetchLocalUser();
  return { user };
 } catch (e) {
  console.warn('[Auth] fetchMe error:', e);
  return { user: null };
 }
}

async function fetchEntitlement(): Promise<Entitlement> {
 if (AUTH_MODE !== 'cloudflare') return fallbackToFree('local mode', 'fetchEntitlement');
 
 try {
  const entitlement = await fetchLocalEntitlement();
  return {
   isPro: entitlement.isPro,
   plan: entitlement.plan as 'pro' | 'free',
   betaAccess: entitlement.betaAccess,
   dailyQuota: entitlement.dailyQuota,
  };
 } catch (e) {
  console.warn('[Auth] fetchEntitlement error:', e);
  return fallbackToFree(e instanceof Error ? e.message : 'fetch error', 'fetchEntitlement');
 }
}

export function AuthProvider({ children }: { children: React.ReactNode }) {
 const [state, setState] = useState<{ 
  authReady: boolean; 
  user: User | null;
  entitlement: Entitlement;
 }>({
  authReady: false,
  user: null,
  entitlement: { isPro: false, plan: 'free' },
 });

 const refreshAuth = async () => {
  try {
   console.log(`[Auth] Refreshing auth (mode: ${AUTH_MODE})`);
   
   // Fetch user and entitlement in parallel
   const [userResponse, entitlement] = await Promise.all([
    fetchMe(),
    fetchEntitlement()
   ]);
   
   // ðŸš¨ ZOMBIE SESSION DETECTION: User exists but no token
   const token = getToken();
   if (userResponse.user && !token) {
    console.error('ðŸ§Ÿ ZOMBIE SESSION DETECTED: User exists but no auth token!');
    console.error('This will cause all API calls to fail with 401.');
    
    // Clear the zombie session and force re-login
    setState({
     authReady: true,
     user: null, // Force logout state
     entitlement: { isPro: false, plan: 'free' },
    });
    
    // Show user-friendly error
    if (typeof window !== 'undefined') {
     // Dispatch event for UI to show re-login prompt
     window.dispatchEvent(new CustomEvent('auth-zombie-detected'));
    }
    return;
   }
   
   setState({
    authReady: true,
    user: userResponse.user,
    entitlement,
   });
  } catch (error) {
   console.warn('[Auth] Refresh error:', error);
   setState({
    authReady: true,
    user: null,
    entitlement: { isPro: false, plan: 'free' },
   });
  }
 };

 useEffect(() => {
  const isTestRoute = window.location.pathname.startsWith('/dev/local-test');
  const isBypassed = isTestRoute || (window as any).__DISABLE_AUTH__ || AUTH_MODE === 'local';

  // In these cases we don't hit the network at all
  if (isBypassed) {
   console.log('ðŸ”§ Auth bypass active (local mode or test route).');
   setState({ 
    authReady: true, 
    user: null,
    entitlement: { isPro: false, plan: 'free' }
   });
   return;
  }

  const initAuth = async () => {
   try {
    // Preview must not call cross-origin creds; treat as anon
    if (IS_PREVIEW) {
     console.log('ðŸ”§ AuthContext: Preview detected, skipping auth');
     setState({ 
      authReady: true, 
      user: null,
      entitlement: { isPro: false, plan: 'free' }
     });
     return;
    }

    await refreshAuth();
   } catch (error) {
    console.warn('Auth init error:', error);
    setState({ 
     authReady: true, 
     user: null,
     entitlement: { isPro: false, plan: 'free' }
    });
   }
  };

  // If we're on /auth/success with a token, wait for LoginSuccess to signal
  const isAuthSuccess =
   window.location.pathname === '/auth/success' && window.location.search.includes('token=');

  if (isAuthSuccess) {
   console.log('AuthContext: On /auth/success with token, waiting for LoginSuccessâ€¦');
   setState({ 
    authReady: true, 
    user: null,
    entitlement: { isPro: false, plan: 'free' }
   }); // Don't block UI

   const handleAuthSuccess = () => {
    console.log('AuthContext: Received auth-success event, refreshing authâ€¦');
    refreshAuth().catch(err => console.warn('Auth refresh error:', err));
   };

   window.addEventListener('auth-success', handleAuthSuccess);
   return () => window.removeEventListener('auth-success', handleAuthSuccess);
  }

  initAuth().catch(err => console.warn('Auth init error:', err));
 }, []);

 const logout = async () => {
  const isTestRoute = window.location.pathname.startsWith('/dev/local-test');
  const isBypassed = isTestRoute || (window as any).__DISABLE_AUTH__ || AUTH_MODE === 'local';

  if (isBypassed) {
   console.log('ðŸ”§ Logout bypassed (local mode or test route).');
   setState((s) => ({ ...s, user: null, entitlement: { isPro: false, plan: 'free' } }));
   return;
  }

  try {
   await fetch('/auth/logout', { method: 'POST', credentials: 'include' });
  } catch (e) {
   console.warn('Logout call failed (ignored in UI):', e);
  }
  setState((s) => ({ ...s, user: null, entitlement: { isPro: false, plan: 'free' } }));
 };

 const contextValue: AuthContextType = {
  ...state,
  isAuthed: !!state.user,
  isAuthenticated: !!state.user, // Alias for compatibility
  isPro: !!state.user?.isPro || !!state.entitlement?.isPro, // Computed helper
  plan: state.user?.plan || state.entitlement?.plan || 'free',
  token: getToken(),
  logout,
  refreshAuth,
 };

 // Expose auth debug info to window in development
 useEffect(() => {
  if (typeof window !== 'undefined') {
   (window as any).__AUTH__ = {
    user: state.user,
    entitlement: state.entitlement,
    isAuthed: !!state.user,
    isAuthenticated: !!state.user, // âœ… CRITICAL FIX: Add missing isAuthenticated
    plan: state.user?.plan || state.entitlement?.plan || 'free',
    token: getToken(),
    getUserId: () => state.user?.id || 'Not logged in',
    getEmail: () => state.user?.email || 'Not logged in',
    refreshAuth
   };
   
   // ðŸ“Š Track auth context loaded for funnel monitoring
   if (typeof window !== 'undefined' && (window as any).posthog && state.authReady) {
    (window as any).posthog.capture('auth_context_loaded', {
     isAuthenticated: !!state.user,
     user_id: state.user?.id || null,
     plan: state.user?.plan || state.entitlement?.plan || 'free'
    });
   }
   console.log('Auth debug available: __AUTH__.getUserId(), __AUTH__.getEmail(), __AUTH__.user');
  }
 }, [state, refreshAuth]);

 return <AuthContext.Provider value={contextValue}>{children}</AuthContext.Provider>;
}

export const useAuth = () => useContext(AuthContext);
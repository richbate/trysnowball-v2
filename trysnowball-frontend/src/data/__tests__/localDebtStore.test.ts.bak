/**
 * CP-1: Tests for LocalDebtStore
 * 
 * Comprehensive test suite for the new IndexedDB-based debt store
 */

import 'fake-indexeddb/auto';
import { localDebtStore } from '../localDebtStore';
import { Debt } from '../../types/debt';

describe('LocalDebtStore', () => {
 beforeEach(async () => {
  // Clear all data before each test
  await localDebtStore.clearAll();
  await localDebtStore.setMeta('migration_completed_v2', false);
 });

 describe('CRUD Operations', () => {
  it('should create a new debt', async () => {
   const debtId = await localDebtStore.upsertDebt({
    name: 'Test Visa',
    balance: 1000,
    interestRate: 19.9,
    minPayment: 25,
    type: 'Credit Card'
   });

   expect(debtId).toBeTruthy();
   
   const debt = await localDebtStore.getDebt(debtId);
   expect(debt).toBeTruthy();
   expect(debt?.name).toBe('Test Visa');
   expect(debt?.balance).toBe(1000);
   expect(debt?.interestRate).toBe(19.9);
   expect(debt?.minPayment).toBe(25);
   expect(debt?.type).toBe('Credit Card');
  });

  it('should update an existing debt', async () => {
   const debtId = await localDebtStore.upsertDebt({
    name: 'Test Debt',
    balance: 1000,
    interestRate: 10,
    minPayment: 50
   });

   await localDebtStore.upsertDebt({
    id: debtId,
    balance: 900,
    minPayment: 45
   });

   const updated = await localDebtStore.getDebt(debtId);
   expect(updated?.balance).toBe(900);
   expect(updated?.minPayment).toBe(45);
   expect(updated?.name).toBe('Test Debt'); // Unchanged
   expect(updated?.interestRate).toBe(10); // Unchanged
  });

  it('should list all debts in order', async () => {
   await localDebtStore.upsertDebt({
    name: 'Debt 3',
    balance: 300,
    order: 2
   });
   await localDebtStore.upsertDebt({
    name: 'Debt 1',
    balance: 100,
    order: 0
   });
   await localDebtStore.upsertDebt({
    name: 'Debt 2',
    balance: 200,
    order: 1
   });

   const debts = await localDebtStore.listDebts();
   expect(debts).toHaveLength(3);
   expect(debts[0].name).toBe('Debt 1');
   expect(debts[1].name).toBe('Debt 2');
   expect(debts[2].name).toBe('Debt 3');
  });

  it('should delete a debt and its related data', async () => {
   const debtId = await localDebtStore.upsertDebt({
    name: 'To Delete',
    balance: 500
   });

   // Add a payment
   await localDebtStore.recordPayment({
    debtId,
    amount: 100,
    date: new Date().toISOString(),
    month: '2024-01',
    type: 'minimum'
   });

   // Delete the debt
   await localDebtStore.deleteDebt(debtId);

   // Verify deletion
   const debt = await localDebtStore.getDebt(debtId);
   expect(debt).toBeNull();

   // Verify payments also deleted
   const payments = await localDebtStore.getPayments({ debtId });
   expect(payments).toHaveLength(0);
  });

  it('should bulk upsert multiple debts', async () => {
   const debts: Partial<Debt>[] = [
    { name: 'Debt 1', balance: 100 },
    { name: 'Debt 2', balance: 200 },
    { name: 'Debt 3', balance: 300 }
   ];

   await localDebtStore.upsertMany(debts);

   const saved = await localDebtStore.listDebts();
   expect(saved).toHaveLength(3);
   expect(saved.map(d => d.name)).toEqual(['Debt 1', 'Debt 2', 'Debt 3']);
  });
 });

 describe('Payment Operations', () => {
  it('should record a payment and update debt balance', async () => {
   const debtId = await localDebtStore.upsertDebt({
    name: 'Payment Test',
    balance: 1000,
    minPayment: 50
   });

   await localDebtStore.recordPayment({
    debtId,
    amount: 150,
    date: '2024-01-15',
    month: '2024-01',
    type: 'extra'
   });

   const debt = await localDebtStore.getDebt(debtId);
   expect(debt?.balance).toBe(850); // 1000 - 150

   const payments = await localDebtStore.getPayments({ debtId });
   expect(payments).toHaveLength(1);
   expect(payments[0].amount).toBe(150);
   expect(payments[0].type).toBe('extra');
  });

  it('should retrieve payments by month', async () => {
   const debtId = await localDebtStore.upsertDebt({
    name: 'Monthly Test',
    balance: 1000
   });

   await localDebtStore.recordPayment({
    debtId,
    amount: 100,
    date: '2024-01-15',
    month: '2024-01',
    type: 'minimum'
   });

   await localDebtStore.recordPayment({
    debtId,
    amount: 200,
    date: '2024-02-15',
    month: '2024-02',
    type: 'extra'
   });

   const janPayments = await localDebtStore.getPayments({ month: '2024-01' });
   expect(janPayments).toHaveLength(1);
   expect(janPayments[0].amount).toBe(100);

   const febPayments = await localDebtStore.getPayments({ month: '2024-02' });
   expect(febPayments).toHaveLength(1);
   expect(febPayments[0].amount).toBe(200);
  });

  it('should not allow negative balances', async () => {
   const debtId = await localDebtStore.upsertDebt({
    name: 'Overpayment Test',
    balance: 100
   });

   await localDebtStore.recordPayment({
    debtId,
    amount: 150, // More than balance
    date: '2024-01-15',
    month: '2024-01',
    type: 'extra'
   });

   const debt = await localDebtStore.getDebt(debtId);
   expect(debt?.balance).toBe(0); // Should be 0, not negative
  });
 });

 describe('Demo Data', () => {
  it('should load demo data', async () => {
   await localDebtStore.loadDemoData();

   const debts = await localDebtStore.listDebts();
   expect(debts.length).toBeGreaterThanOrEqual(3);
   
   const demoDebts = debts.filter(d => d.isDemo);
   expect(demoDebts.length).toBeGreaterThanOrEqual(3);
   
   // Check demo data structure
   const visa = debts.find(d => d.name === 'Visa Card');
   expect(visa).toBeTruthy();
   expect(visa?.balance).toBe(3500);
   expect(visa?.interestRate).toBe(19.9);
  });

  it('should clear only demo data', async () => {
   // Add real debt
   await localDebtStore.upsertDebt({
    name: 'Real Debt',
    balance: 1000,
    isDemo: false
   });

   // Load demo data
   await localDebtStore.loadDemoData();

   const allDebts = await localDebtStore.listDebts();
   const initialCount = allDebts.length;
   expect(initialCount).toBeGreaterThanOrEqual(4); // 1 real + 3+ demo

   // Clear demo data
   await localDebtStore.clearDemoData();

   const remaining = await localDebtStore.listDebts();
   expect(remaining).toHaveLength(1);
   expect(remaining[0].name).toBe('Real Debt');
   expect(remaining[0].isDemo).toBe(false);
  });

  it('should filter demo debts when requested', async () => {
   await localDebtStore.upsertDebt({
    name: 'Real Debt',
    balance: 1000,
    isDemo: false
   });

   await localDebtStore.loadDemoData();

   const allDebts = await localDebtStore.listDebts({ includeDemo: true });
   expect(allDebts.length).toBeGreaterThanOrEqual(4);

   const realOnly = await localDebtStore.listDebts({ includeDemo: false });
   expect(realOnly).toHaveLength(1);
   expect(realOnly[0].name).toBe('Real Debt');
  });
 });

 describe('Metadata Operations', () => {
  it('should store and retrieve metadata', async () => {
   await localDebtStore.setMeta('test_key', 'test_value');
   const value = await localDebtStore.getMeta('test_key');
   expect(value).toBe('test_value');
  });

  it('should store complex metadata', async () => {
   const complexData = {
    lastSync: '2024-01-15T10:00:00Z',
    syncCount: 5,
    settings: {
     theme: 'dark',
     currency: 'GBP'
    }
   };

   await localDebtStore.setMeta('sync_info', complexData);
   const retrieved = await localDebtStore.getMeta('sync_info');
   expect(retrieved).toEqual(complexData);
  });

  it('should track migration status', async () => {
   const needsMigration = await localDebtStore.needsMigration();
   expect(needsMigration).toBe(true);

   await localDebtStore.markMigrationComplete();

   const stillNeeds = await localDebtStore.needsMigration();
   expect(stillNeeds).toBe(false);

   const migrationDate = await localDebtStore.getMeta('migration_date');
   expect(migrationDate).toBeTruthy();
  });
 });

 describe('Data Normalization', () => {
  it('should normalize string amounts to numbers', async () => {
   const debtId = await localDebtStore.upsertDebt({
    name: 'String Test',
    balance: '1,234.56' as any,
    interestRate: '19.9%' as any,
    minPayment: 'Â£25.00' as any
   });

   const debt = await localDebtStore.getDebt(debtId);
   expect(debt?.balance).toBe(1234.56);
   expect(debt?.interestRate).toBe(19.9);
   expect(debt?.minPayment).toBe(25);
  });

  it('should handle invalid data gracefully', async () => {
   const debtId = await localDebtStore.upsertDebt({
    name: 'Invalid Test',
    balance: 'invalid' as any,
    interestRate: null as any,
    minPayment: undefined as any
   });

   const debt = await localDebtStore.getDebt(debtId);
   expect(debt?.balance).toBe(0);
   expect(debt?.interestRate).toBe(0);
   expect(debt?.minPayment).toBe(0);
  });
 });

 describe('Snapshot Operations', () => {
  it('should create snapshots when recording payments', async () => {
   const debtId = await localDebtStore.upsertDebt({
    name: 'Snapshot Test',
    balance: 1000
   });

   await localDebtStore.recordPayment({
    debtId,
    amount: 100,
    date: '2024-01-15',
    month: '2024-01',
    type: 'minimum'
   });

   const snapshots = await localDebtStore.getSnapshots(debtId);
   expect(snapshots.length).toBeGreaterThanOrEqual(1);
   
   const latest = snapshots[0];
   expect(latest.balance).toBe(900);
   expect(latest.eventType).toBe('payment');
  });
 });

 describe('Error Handling', () => {
  it('should handle database errors gracefully', async () => {
   // Try to get non-existent debt
   const debt = await localDebtStore.getDebt('non-existent');
   expect(debt).toBeNull();
  });

  it('should handle empty list operations', async () => {
   const debts = await localDebtStore.listDebts();
   expect(debts).toEqual([]);

   const payments = await localDebtStore.getPayments();
   expect(payments).toEqual([]);
  });
 });

 describe('Idempotence', () => {
  it('should handle repeated upserts idempotently', async () => {
   const debtData = {
    id: 'fixed-id',
    name: 'Idempotent Test',
    balance: 1000
   };

   await localDebtStore.upsertDebt(debtData);
   await localDebtStore.upsertDebt(debtData);
   await localDebtStore.upsertDebt(debtData);

   const debts = await localDebtStore.listDebts();
   expect(debts).toHaveLength(1);
   expect(debts[0].name).toBe('Idempotent Test');
  });

  it('should handle repeated demo loads idempotently', async () => {
   await localDebtStore.loadDemoData();
   await localDebtStore.loadDemoData();
   
   const debts = await localDebtStore.listDebts();
   const demoDebts = debts.filter(d => d.isDemo);
   
   // Should not duplicate demo debts
   const visaCards = demoDebts.filter(d => d.name === 'Visa Card');
   expect(visaCards).toHaveLength(1);
  });
 });
});
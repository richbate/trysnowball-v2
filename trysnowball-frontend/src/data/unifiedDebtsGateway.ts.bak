/**
 * Unified Debts Gateway - Single Source of Truth
 * 
 * Canonical debt API gateway using RouteRegistry.
 * Replaces both debtsGateway.ts and cleanDebtsGateway.ts
 */

import { UKDebt } from '../types/ukDebt';
import { getToken } from '../utils/tokenStorage';
import { RouteRegistry, RouteHelpers } from '../routes/routeRegistry';
import { GatewayAnalytics, RouteAnalytics } from '../utils/routeAnalytics';

/**
 * Map URL back to route key for analytics
 */
function getRouteKeyFromUrl(url: string): string {
  if (url.includes('/api/clean/debts')) {
    if (url.includes('/api/clean/debts/')) {
      return 'debts.update'; // Both PUT and DELETE use same route key
    }
    return 'debts.getAll'; // GET and POST to /api/clean/debts
  }
  if (url.includes('/auth/me')) return 'auth.me';
  if (url.includes('/auth/refresh')) return 'auth.refresh';
  if (url.includes('/auth/request-link')) return 'auth.requestLink';
  if (url.includes('/auth/logout')) return 'auth.logout';
  return 'unknown.route';
}

// API error handling
class DebtsAPIError extends Error {
  constructor(message: string, public status?: number) {
    super(message);
    this.name = 'DebtsAPIError';
  }
}

/**
 * Gateway telemetry for monitoring
 */
function emitGatewayTelemetry(operation: string, status: 'success' | 'error', route: string) {
  try {
    if (typeof window !== 'undefined' && window.posthog) {
      window.posthog.capture('debts_gateway_operation', { 
        operation, 
        status, 
        route,
        timestamp: Date.now() 
      });
    }
  } catch (e) {
    // Ignore telemetry errors
  }
}

/**
 * Common request headers with authentication and client validation
 */
function getAuthHeaders(): Record<string, string> {
  const token = getToken();
  if (!token) {
    throw new DebtsAPIError('No auth token available', 401);
  }

  // Determine client ID based on environment
  const getClientId = () => {
    if (typeof window !== 'undefined') {
      // Browser environment
      if (window.location.hostname === 'localhost' || window.location.hostname.includes('127.0.0.1')) {
        return 'dev-local';
      }
      if (window.location.hostname.includes('staging')) {
        return 'web-v1-staging';
      }
      return 'web-v1';
    }
    // Server-side/test environment
    return 'dev-local';
  };

  return {
    'Authorization': `Bearer ${token}`,
    'Content-Type': 'application/json',
    'x-client-id': getClientId()
  };
}

/**
 * Enhanced fetch with error handling and telemetry
 */
async function fetchWithAuth(url: string, options: RequestInit = {}): Promise<Response> {
  const headers = getAuthHeaders();
  const startTime = Date.now();
  const method = options.method || 'GET';
  
  // Start tracking with PostHog
  RouteAnalytics.apiCallStarted(getRouteKeyFromUrl(url), method as any);
  
  try {
    const response = await fetch(url, {
      ...options,
      headers: {
        ...headers,
        ...options.headers
      }
    });

    const responseTime = Date.now() - startTime;

    if (!response.ok) {
      // Track failure with PostHog
      RouteAnalytics.apiCallError(getRouteKeyFromUrl(url), method as any, `HTTP_${response.status}`);
      emitGatewayTelemetry(method, 'error', url);
      
      let errorMessage = `HTTP ${response.status}`;
      try {
        const errorData = await response.json();
        errorMessage = errorData.error || errorMessage;
      } catch {
        // Use default error message if response isn't JSON
      }
      
      throw new DebtsAPIError(errorMessage, response.status);
    }

    // Track success with PostHog
    RouteAnalytics.apiCallSuccess(getRouteKeyFromUrl(url), method as any, responseTime);
    emitGatewayTelemetry(method, 'success', url);
    return response;
  } catch (error) {
    const responseTime = Date.now() - startTime;
    if (error instanceof DebtsAPIError) {
      throw error; // Re-throw our own errors
    }
    
    // Network or other errors
    RouteAnalytics.apiCallError(getRouteKeyFromUrl(url), method as any, 'NETWORK_ERROR');
    emitGatewayTelemetry(method, 'error', url);
    throw error;
  }
}

/**
 * GET all debts for current user
 */
export async function fetchAllDebts(): Promise<UKDebt[]> {
  console.log('üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø [UNIFIED_GATEWAY] Fetching all debts');
  
  const response = await fetchWithAuth(RouteHelpers.getRoute('debts.getAll'), {
    method: 'GET'
  });

  const data = await response.json();
  console.log('üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø [UNIFIED_GATEWAY] Fetched', data.debts.length, 'debts');
  
  // Track successful debt viewing
  RouteAnalytics.debtOperation('viewed');
  
  return data.debts;
}

/**
 * Sanitize debt object by removing undefined values
 * D1 doesn't accept undefined values, only null or actual values
 */
function sanitizeDebtForD1(debt: any): any {
  const sanitized: any = {};
  for (const [key, value] of Object.entries(debt)) {
    // Skip undefined values completely
    if (value !== undefined && value !== null && value !== '') {
      // Convert string numbers to actual numbers for numeric fields
      if (['amount_cents', 'min_payment_cents', 'apr', 'order_index'].includes(key)) {
        const numValue = typeof value === 'string' ? parseFloat(value) : value;
        if (!isNaN(numValue) && isFinite(numValue)) {
          sanitized[key] = numValue;
        }
      } else {
        sanitized[key] = value;
      }
    }
  }
  
  // Ensure required fields have defaults if missing
  if (!sanitized.created_at) {
    sanitized.created_at = new Date().toISOString();
  }
  if (!sanitized.updated_at) {
    sanitized.updated_at = new Date().toISOString();
  }
  
  console.log('üîß [SANITIZE] Input:', debt);
  console.log('üîß [SANITIZE] Output:', sanitized);
  
  return sanitized;
}

/**
 * POST create new debt
 */
export async function createDebt(debt: UKDebt): Promise<UKDebt> {
  console.log('üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø [UNIFIED_GATEWAY] Creating debt:', debt.name);
  
  // Sanitize debt to remove undefined values (D1 doesn't accept them)
  const sanitizedDebt = sanitizeDebtForD1(debt);
  console.log('üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø [UNIFIED_GATEWAY] Sanitized debt for D1:', sanitizedDebt);
  
  const response = await fetchWithAuth(RouteHelpers.getRoute('debts.create'), {
    method: 'POST',
    body: JSON.stringify(sanitizedDebt)
  });

  const data = await response.json();
  console.log('üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø [UNIFIED_GATEWAY] ‚úÖ Debt created:', data.debt.id);
  
  // Track successful debt creation
  RouteAnalytics.debtOperation('created', data.debt.id);
  
  return data.debt;
}

/**
 * PUT update existing debt
 */
export async function updateDebt(debtId: string, updates: Partial<UKDebt>): Promise<void> {
  console.log('üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø [UNIFIED_GATEWAY] Updating debt:', debtId);
  
  // Sanitize updates to remove undefined values (D1 doesn't accept them)
  console.log('üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø [UNIFIED_GATEWAY] Raw updates before sanitization:', updates);
  const sanitizedUpdates = sanitizeDebtForD1(updates);
  console.log('üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø [UNIFIED_GATEWAY] Sanitized updates for D1:', sanitizedUpdates);
  
  // Check if any values are still undefined
  for (const [key, value] of Object.entries(sanitizedUpdates)) {
    if (value === undefined) {
      console.error(`üö® [UNIFIED_GATEWAY] UNDEFINED VALUE FOUND: ${key} = ${value}`);
    }
  }
  
  // Double-check: stringify with replacer to remove undefined values
  const safeBody = JSON.stringify(sanitizedUpdates, (key, value) => {
    if (value === undefined) {
      console.error(`üö® Found undefined in JSON.stringify: ${key}`);
      return null; // Convert undefined to null for D1
    }
    return value;
  });
  
  console.log('üì§ [UNIFIED_GATEWAY] Final JSON being sent:', safeBody);
  
  await fetchWithAuth(RouteHelpers.getRoute('debts.update', debtId), {
    method: 'PUT',
    body: safeBody
  });

  console.log('üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø [UNIFIED_GATEWAY] ‚úÖ Debt updated:', debtId);
  
  // Track successful debt update
  RouteAnalytics.debtOperation('updated', debtId);
}

/**
 * DELETE remove debt
 */
export async function deleteDebt(debtId: string): Promise<void> {
  console.log('üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø [UNIFIED_GATEWAY] Deleting debt:', debtId);
  
  await fetchWithAuth(RouteHelpers.getRoute('debts.delete', debtId), {
    method: 'DELETE'
  });

  console.log('üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø [UNIFIED_GATEWAY] ‚úÖ Debt deleted:', debtId);
  
  // Track successful debt deletion
  RouteAnalytics.debtOperation('deleted', debtId);
}

/**
 * Upsert debt (create or update based on ID presence)
 */
export async function upsertDebt(debt: UKDebt): Promise<UKDebt> {
  // No need to sanitize here since createDebt and updateDebt handle it
  if (debt.id && debt.id.length > 0) {
    // Update existing debt
    await updateDebt(debt.id, debt);
    return debt;
  } else {
    // Create new debt
    return await createDebt(debt);
  }
}

/**
 * Batch operations for efficiency
 */
export async function batchCreateDebts(debts: UKDebt[]): Promise<UKDebt[]> {
  console.log('üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø [UNIFIED_GATEWAY] Batch creating', debts.length, 'debts');
  
  // For now, create sequentially. Can be optimized to use batch endpoint later.
  const results: UKDebt[] = [];
  
  for (const debt of debts) {
    const result = await createDebt(debt);
    results.push(result);
  }
  
  console.log('üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø [UNIFIED_GATEWAY] ‚úÖ Batch created', results.length, 'debts');
  return results;
}

/**
 * Health check for debt API
 */
export async function healthCheck(): Promise<boolean> {
  try {
    // Try to fetch debts - if it works, API is healthy
    await fetchAllDebts();
    return true;
  } catch (error) {
    console.warn('üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø [UNIFIED_GATEWAY] Health check failed:', error);
    return false;
  }
}

// Export error class for external use
export { DebtsAPIError };
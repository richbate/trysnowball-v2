/**
 * Demo Debts Hook (DEPRECATED)
 * 
 * WARNING: This hook is deprecated in favor of unified IndexedDB demo data.
 * Use useUserDebts instead, which automatically handles both real and demo data
 * based on DemoModeProvider context.
 * 
 * TODO: Remove this hook after confirming no components still reference it.
 */

import { useState, useEffect, useMemo } from 'react';
import { demoStorage } from '../../lib/demoStorage';
import { generatePayoffTimeline } from '../../utils/DebtEngine';

export const useDemoDebts = () => {
 // Deprecation warning
 if (process.env.NODE_ENV !== 'production') {
  console.warn('[DEPRECATION] useDemoDebts is deprecated. Use useUserDebts instead, which handles both real and demo data.');
 }
 
 const [debts, setDebts] = useState(() => demoStorage.getDebts());
 const [extraPayment, setExtraPayment] = useState(() => demoStorage.getExtraPayment());
 const [strategy, setStrategy] = useState(() => demoStorage.getStrategy());
 
 // Sync with demo storage
 useEffect(() => {
  demoStorage.setDebts(debts);
 }, [debts]);
 
 useEffect(() => {
  demoStorage.setExtraPayment(extraPayment);
 }, [extraPayment]);
 
 useEffect(() => {
  demoStorage.setStrategy(strategy);
 }, [strategy]);
 
 // Calculate projections using DebtEngine
 const projections = useMemo(() => {
  if (!debts || debts.length === 0) {
   return {
    totalPayoffMonths: 0,
    totalInterest: 0,
    monthlyPayment: 0,
    debtFreeDate: null,
    timeline: [],
    strategy
   };
  }
  
  try {
   const sortedDebts = strategy === 'avalanche' 
    ? [...debts].sort((a, b) => (b.rate || 0) - (a.rate || 0))
    : [...debts].sort((a, b) => (a.balance || 0) - (b.balance || 0));
   
   const totalMinPayments = sortedDebts.reduce((sum, debt) => sum + (debt.minimumPayment || 0), 0);
   const timeline = generatePayoffTimeline(sortedDebts, totalMinPayments + extraPayment);
   const totalMonths = timeline[timeline.length - 1]?.month || 0;
   const totalInterest = timeline.reduce((sum, t) => sum + (t.interestPaid || 0), 0);
   const monthlyPayment = debts.reduce((sum, d) => sum + (d.minimumPayment || 0), 0) + extraPayment;
   
   const debtFreeDate = totalMonths > 0
    ? new Date(Date.now() + totalMonths * 30 * 24 * 60 * 60 * 1000)
    : null;
   
   return {
    totalPayoffMonths: totalMonths,
    totalInterest,
    monthlyPayment,
    debtFreeDate,
    timeline,
    strategy
   };
  } catch (error) {
   console.warn('Error calculating demo projections:', error);
   return {
    totalPayoffMonths: 0,
    totalInterest: 0,
    monthlyPayment: 0,
    debtFreeDate: null,
    timeline: [],
    strategy
   };
  }
 }, [debts, extraPayment, strategy]);
 
 // CRUD operations for demo mode
 const addDebt = (debt) => {
  const newDebt = {
   ...debt,
   id: `demo_${Date.now()}`,
   created: new Date().toISOString(),
   lastUpdated: new Date().toISOString()
  };
  setDebts([...debts, newDebt]);
  return newDebt;
 };
 
 const updateDebt = (id, updates) => {
  setDebts(debts.map(d => 
   d.id === id 
    ? { ...d, ...updates, lastUpdated: new Date().toISOString() }
    : d
  ));
 };
 
 const deleteDebt = (id) => {
  setDebts(debts.filter(d => d.id !== id));
 };
 
 const clearDebts = () => {
  setDebts([]);
 };
 
 // Balance update functions
 const updateBalances = (balanceMap) => {
  setDebts(debts.map(debt => {
   const newBalance = balanceMap[debt.id];
   if (newBalance !== undefined) {
    return { ...debt, balance: newBalance, lastUpdated: new Date().toISOString() };
   }
   return debt;
  }));
  
  // Update last balance update timestamp
  sessionStorage.setItem('DEMO_LAST_BALANCE_UPDATE', new Date().toISOString());
 };
 
 // Computed values
 const totalDebt = useMemo(() => 
  debts.reduce((sum, debt) => sum + (debt.amount_pennies || debt.amount || 0), 0),
  [debts]
 );
 
 const totalMinimum = useMemo(() =>
  debts.reduce((sum, debt) => sum + (debt.minimumPayment || 0), 0),
  [debts]
 );
 
 const hasDebts = debts.length > 0;
 const debtCount = debts.length;
 
 return {
  // Data
  debts,
  extraPayment,
  strategy,
  projections,
  
  // Computed
  totalDebt,
  totalMinimum,
  hasDebts,
  debtCount,
  
  // Actions
  addDebt,
  updateDebt,
  deleteDebt,
  clearDebts,
  updateBalances,
  setExtraPayment,
  setStrategy,
  
  // Status
  isLoading: false,
  error: null,
  isDemo: true
 };
};
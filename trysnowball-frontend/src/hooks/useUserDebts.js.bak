import { useEffect, useRef, useState } from 'react';
import shallowEqual from '../utils/shallowEqual';
import { useAuthStatus } from './useAuthStatus';
import { localDebtStore } from '../data/localDebtStore'; // existing store
import { secureAnalytics } from '../utils/secureAnalytics';
import { fetchAllDebts as fetchDebts, upsertDebt as gatewayUpsertDebt, deleteDebt as gatewayDeleteDebt } from '../data/unifiedDebtsGateway';
import { useDebtConversionTracker } from './useDebtConversionTracker';
import { safeNormalizeDebts, safeNormalizeDebt } from '../utils/safeDebtNormalizer';
import { validateDebt, validateDebts } from '../lib/validateDebt';
import { useDemoMode } from '../providers/DemoModeProvider';
import { encryptJSON, getOrCreateUserKey, isCryptoAvailable } from '../lib/crypto';
import { fromCents, bpsToPercent } from '../lib/money';
// import type { NormalizedDebt } from '../adapters/debts';

export function useUserDebts() {
 const { status } = useAuthStatus();
 const { isDemo } = useDemoMode();
 const { markDebtAdded } = useDebtConversionTracker();
 const [debts, setDebts] = useState([]);    // never undefined
 const [loading, setLoading] = useState(true); // loading reflects fetch/local load
 const [error, setError] = useState(null);
 const hasTriedServerRef = useRef(false); // Track if we've tried server
 const [hydrationStatus, setHydrationStatus] = useState('idle'); // 'idle' | 'hydrating' | 'ready'
 const [syncing, setSyncing] = useState(false);
 const fetching = useRef(false);
 const lastDebtsRef = useRef([]);
 const hydrationTimings = useRef({ start: 0, authReady: 0, localLoaded: 0, remoteLoaded: 0 });

 // Helper to set debts only if they actually changed (prevent unnecessary re-renders)
 const updateDebts = (newDebts) => {
  if (!shallowEqual(newDebts, lastDebtsRef.current)) {
   setDebts(newDebts);
   lastDebtsRef.current = newDebts;
   
   // dev boobytrap: catch mutations
   if (process.env.NODE_ENV === 'development') {
    Object.freeze(newDebts);
    newDebts.forEach?.(Object.freeze);
   }
  }
 };

 // Reset server attempt flag when auth status changes to authenticated
 useEffect(() => {
  if (status === 'authenticated') {
   hasTriedServerRef.current = false;
  }
 }, [status]);

 // Track hydration status and timings
 // eslint-disable-next-line react-hooks/exhaustive-deps
 useEffect(() => {
  if (status === 'checking') {
   setHydrationStatus('idle');
   hydrationTimings.current.start = Date.now();
  } else if (status !== 'checking' && hydrationStatus === 'idle') {
   setHydrationStatus('hydrating');
   hydrationTimings.current.authReady = Date.now();
  }
 }, [status]);

 useEffect(() => {
  let cancelled = false;
  const effectId = Math.random().toString(36).substr(2, 9);
  console.log(`ðŸ” [DEBUG] useUserDebts effect ${effectId} starting - status: ${status}, hydrationStatus: ${hydrationStatus}, hasTriedServer: ${hasTriedServerRef.current}, isDemo: ${isDemo}`);

  async function load() {
   if (fetching.current) {
    console.log(`ðŸ” [DEBUG] Effect ${effectId}: Already fetching, returning`);
    return;
   }
   console.log(`ðŸ” [DEBUG] Effect ${effectId}: Starting load`);
   fetching.current = true;
   setLoading(true);
   setError(null);
   setHydrationStatus('hydrating');
   
   // Start timing
   hydrationTimings.current.start = Date.now();
   hydrationTimings.current.authReady = Date.now();

   try {
    // One-time migration of legacy debts (non-blocking)
    try {
     const { migrateLegacyDebts } = await import('../data/migrations/migrateLegacyDebts');
     migrateLegacyDebts().catch(err => {
      console.warn('[Migration] Background migration failed:', err);
     });
    } catch (migrationError) {
     console.debug('[Migration] Could not run migration:', migrationError);
    }
    
    console.log(`ðŸ” [DEBUG] Hydration load() - status: ${status}, isDemo: ${isDemo}`);
    
    if (status === 'checking') {
     console.log('ðŸ” [DEBUG] Status is checking, returning early');
     return;
    }

    if (status === 'anonymous' || status === 'error') {
     console.log('ðŸ” [DEBUG] Taking anonymous path, loading from localStorage...');
     // Anonymous path â†’ localStorage only - simplified approach
     try {
      const all = await localDebtStore.listDebts({ includeDemo: isDemo });
      console.log(`ðŸ” [DEBUG] Raw data from localDebtStore.listDebts:`, all);
      hydrationTimings.current.localLoaded = Date.now();
      
      // Only warn about missing demo data if we're actually in demo mode and anonymous
      if (isDemo && status === 'anonymous' && (!all || all.length === 0)) {
       console.warn('[Demo] No demo data found in IndexedDB. DemoModeProvider should have seeded this.');
       console.warn('[Demo] Debug info - isDemo:', isDemo, 'status:', status, 'data length:', all?.length, 'sessionStorage DEMO_IS_ACTIVE:', sessionStorage.getItem('DEMO_IS_ACTIVE'));
      }
      
      const safeDebts = safeNormalizeDebts(Array.isArray(all) ? all : []);
      console.log(`ðŸ” [DEBUG] After normalization: ${safeDebts.length} debts:`, safeDebts);
      
      // Runtime leak detection: ensure demo data doesn't leak into normal lists
      const finalDebts = !isDemo && safeDebts.some(d => d.isDemo) 
       ? safeDebts.filter(d => !d.isDemo)
       : safeDebts;
      
      console.log(`ðŸ” [DEBUG] Final debts count: ${finalDebts.length}`);
      updateDebts(finalDebts);
      setHydrationStatus('ready');
     } catch (error) {
      console.error('ðŸ” [DEBUG] Error in anonymous path:', error);
      updateDebts([]);
      setHydrationStatus('ready');
     }
     return;
    }

    // If status is authenticated but we've already gotten a 401, skip server call
    if (status === 'authenticated' && hasTriedServerRef.current) {
     const all = await localDebtStore.listDebts({ includeDemo: isDemo });
     hydrationTimings.current.localLoaded = Date.now();
     if (!cancelled) {
      const safeDebts = safeNormalizeDebts(Array.isArray(all) ? all : []);
      updateDebts(safeDebts);
      setHydrationStatus('ready');
      // console.log('DEBUG: Authenticated user (401 fallback) loaded', safeDebts.length, 'debts from localStorage');
     }
     return;
    }

    // Authenticated â†’ try remote first, fail-soft to local if remote fails
    try {
     setSyncing(true);
     const normalizedDebts = await fetchDebts();
     hydrationTimings.current.remoteLoaded = Date.now();
     if (!cancelled) {
      const safeDebts = safeNormalizeDebts(normalizedDebts);
      updateDebts(safeDebts);
      console.log('ðŸ”„ Setting hydration ready after remote fetch', { debtCount: safeDebts.length });
      setHydrationStatus('ready');
     }
    } catch (fetchError) {
     // Remote failed - fall back to local data
     const all = await localDebtStore.listDebts({ includeDemo: isDemo });
     hydrationTimings.current.localLoaded = Date.now();
     
     if (!cancelled) {
      const safeDebts = safeNormalizeDebts(Array.isArray(all) ? all : []);
      updateDebts(safeDebts);
      
      // Set appropriate error based on failure type
      if (fetchError.message.includes('401')) {
       hasTriedServerRef.current = true; // Remember we tried and failed
       setError(new Error('Unauthorized â€“ using local debts.'));
      } else {
       setError(new Error('Remote sync failed â€“ using local debts.'));
       
       // Capture remote failure analytics
       try {
        if (typeof window !== 'undefined' && window.posthog) {
         window.posthog.capture('hydration_remote_error', {
          error_type: fetchError.message.includes('401') ? 'auth' : 'network',
          local_count: safeDebts.length,
          fallback_used: true
         });
        }
       } catch (analyticsError) {
        // Ignore analytics errors
       }
      }
      setHydrationStatus('ready');
     }
    } finally {
     setSyncing(false);
    }
   } catch (err) {
    // Last-resort fallback: local + error message
    const all = await localDebtStore.listDebts({ includeDemo: isDemo });
    hydrationTimings.current.localLoaded = Date.now();
    if (!cancelled) {
     const safeDebts = safeNormalizeDebts(Array.isArray(all) ? all : []);
     updateDebts(safeDebts);
     setError(err);
     setHydrationStatus('ready');
    }
   } finally {
    if (!cancelled) {
     setLoading(false);
     
     // Capture hydration timing analytics
     const now = Date.now();
     const timings = hydrationTimings.current;
     const finalDebts = lastDebtsRef.current;
     
     try {
      if (typeof window !== 'undefined' && window.posthog) {
       window.posthog.capture('hydration_timing', {
        auth_ms: timings.authReady - timings.start,
        idb_ms: timings.localLoaded ? timings.localLoaded - timings.authReady : 0,
        remote_ms: timings.remoteLoaded ? timings.remoteLoaded - (timings.localLoaded || timings.authReady) : 0,
        total_ms: now - timings.start,
        decided: finalDebts.length > 0 ? 'hasDebts' : 'noDebts',
        debt_count: finalDebts.length,
        auth_status: status
       });
      }
     } catch (analyticsError) {
      // Never block hydration for analytics
     }
    }
    fetching.current = false;
   }
  }

  // Only run when auth status becomes known
  if (status !== 'checking') {
   console.log(`ðŸ” [DEBUG] Effect ${effectId}: About to call load()`);
   load();
  } else {
   console.log(`ðŸ” [DEBUG] Effect ${effectId}: Status is checking, not calling load`);
  }

  // Failsafe: if hydration is stuck for more than 10 seconds, force ready
  const timeoutId = setTimeout(() => {
   if (hydrationStatus === 'hydrating') {
    console.warn('âš ï¸ Hydration timeout - forcing ready state');
    setHydrationStatus('ready');
   }
  }, 10000);

  return () => {
   console.log(`ðŸ” [DEBUG] Effect ${effectId}: cleanup - cancelling operations`);
   cancelled = true;
   clearTimeout(timeoutId);
  };
 // eslint-disable-next-line react-hooks/exhaustive-deps 
 }, [status, isDemo]);

 // Upsert path must always succeed (local first), then sync later if authed.
 async function upsertDebt(debt) {
  // Normalize debt before any operations
  const normalizedDebt = safeNormalizeDebt(debt);
  if (!normalizedDebt) {
   console.error('Invalid debt data provided to upsertDebt:', debt);
   return;
  }
  
  // Runtime validation in development
  if (process.env.NODE_ENV !== 'production') {
   try {
    validateDebt(normalizedDebt, 'upsertDebt');
   } catch (validationError) {
    console.error('Validation failed in upsertDebt:', validationError.message);
    throw validationError;
   }
  }
  
  // local write: ensure persistence before state update
  console.warn('ðŸ’¾ [DEBT_SAVE] Saving debt to localStorage (FULL OBJECT):', normalizedDebt);
  await localDebtStore.upsertDebt(normalizedDebt);
  console.warn('âœ… [DEBT_SAVE] Debt saved to localStorage successfully');
  
  // ðŸ“Š Track debt save
  if (typeof window !== 'undefined' && window.posthog) {
   window.posthog.capture('debt_saved', {
    debt_id: normalizedDebt.id,
    debt_name: normalizedDebt.name,
    is_authenticated: status === 'authenticated'
   });
  }
  
  // Capture analytics before state update
  let isNewDebt = false;
  let oldBalance = 0;
  const existingDebt = debts.find(d => d.id === normalizedDebt.id);
  
  if (existingDebt) {
   oldBalance = fromCents(existingDebt.amount_pennies); // Convert to GBP for analytics
  } else {
   isNewDebt = true;
  }
  
  setDebts(prev => {
   const map = new Map(prev.map(d => [d.id, d]));
   map.set(normalizedDebt.id, { ...map.get(normalizedDebt.id), ...normalizedDebt });
   const newDebts = Array.from(map.values());
   
   // Track conversion for AB test if this is a new debt
   if (isNewDebt) {
    markDebtAdded(newDebts.length);
   }
   
   return newDebts;
  });
  
  // Fire analytics events (with debug logging)
  try {
   if (process.env.NODE_ENV === 'development') {
    // console.debug('[analytics] Debt operation:', { 
    //  isNewDebt, 
    //  debtId: debt.id, 
    //  oldBalance, 
    //  newBalance: debt.amount_pennies ? fromCents(debt.amount_pennies) : 0,
    //  source: 'useUserDebts.upsertDebt' 
    // });
   }
   
   if (isNewDebt) {
    await secureAnalytics.captureDebtAdded({
     balance: normalizedDebt.amount_pennies || 0,
     name: normalizedDebt.name,
     type: normalizedDebt.debt_type
    }, status === 'authenticated' ? 'pro' : 'free'); // TODO: detect actual user tier
   } else if (normalizedDebt.amount_pennies !== undefined && normalizedDebt.amount_pennies !== (existingDebt?.amount_pennies || 0)) {
    secureAnalytics.captureDebtUpdated(
     oldBalance, 
     fromCents(normalizedDebt.amount_pennies), 
     normalizedDebt.id,
     'user-id-placeholder', // TODO: get actual user ID from auth context
     'useUserDebts.upsertDebt'
    );
   }
   
   // Always capture portfolio snapshot after any debt change 
   // Get current debts list including this update
   const currentDebts = isNewDebt 
    ? [...debts, normalizedDebt]
    : debts.map(d => d.id === normalizedDebt.id ? { ...d, ...normalizedDebt } : d);
    
   await secureAnalytics.capturePortfolioSnapshot(
    currentDebts.map(d => ({
     balance: fromCents(d.amount_pennies),
     type: d.debt_type,
     interestRate: bpsToPercent(d.apr) // bps to percent conversion
    })),
    'user-id-placeholder', // TODO: get actual user ID from auth context
    'useUserDebts.upsertDebt'
   );
   
  } catch (analyticsError) {
   if (process.env.NODE_ENV === 'development') {
    // console.debug('[analytics] Error capturing debt events:', analyticsError);
   }
   // Never block user operations for analytics failures
  }

  if (status === 'authenticated') {
   // Best-effort remote sync using gateway
   try {
    console.warn('ðŸ”„ [SYNC] Attempting sync to D1 for authenticated user...');
    
    // ðŸ“Š Track D1 sync attempt
    if (typeof window !== 'undefined' && window.posthog) {
     window.posthog.capture('d1_sync_started', {
      debt_id: normalizedDebt.id,
      debt_name: normalizedDebt.name
     });
    }
    
    await gatewayUpsertDebt(normalizedDebt, { isUpdate: !isNewDebt });
    console.warn('âœ… [SYNC] Debt successfully synced to D1');
    
    // ðŸ“Š Track successful D1 sync
    if (typeof window !== 'undefined' && window.posthog) {
     window.posthog.capture('d1_sync_success', {
      debt_id: normalizedDebt.id,
      debt_name: normalizedDebt.name
     });
    }
    
    // ðŸŽ‰ Show sync restored toast on first successful sync after auth fix
    const hasShownSyncToast = localStorage.getItem('sync-restored-toast-shown');
    if (!hasShownSyncToast) {
     localStorage.setItem('sync-restored-toast-shown', 'true');
     window.dispatchEvent(new CustomEvent('sync-restored'));
     
     // ðŸ“Š Track sync restored toast
     if (typeof window !== 'undefined' && window.posthog) {
      window.posthog.capture('toast_shown', { id: 'sync_restored' });
     }
    }
   } catch (syncError) {
    console.error('âŒ [SYNC] Failed to sync debt to D1:', syncError);
    console.error('âš ï¸ [SYNC] Debt saved locally but NOT synced to server!');
    // swallow; UI already updated locally
   }
  } else {
   console.warn('ðŸ‘¤ [SYNC] User not authenticated, skipping D1 sync');
  }
 }

 // Calculate totals from normalized fields (converting from cents)
 const totalDebt = debts.reduce((sum, debt) => {
  const amount = fromCents(debt.amount_pennies);
  return sum + amount;
 }, 0);
 
 const totalMinPayments = debts.reduce((sum, debt) => {
  const payment = fromCents(debt.min_payment_pennies);
  return sum + payment;
 }, 0);
 const paymentHistory = [];  // TODO: implement if needed
 const projections = null;   // TODO: implement if needed
 const isAuthenticated = (status === 'authenticated');
 const addDebt = async (debt) => {
  return upsertDebt(debt);
 };

 const updateDebt = async (id, updates) => {
  // Explicit field mapping to satisfy ESLint no-spread rule
  // Note: This is internal data handling, not UI currency conversion
  const debtUpdate = {
   id,
   name: updates.name,
   amount_pennies: updates.amount_pennies, // eslint-disable-line no-restricted-syntax -- Internal field - already in pence
   apr: updates.apr,
   min_payment_pennies: updates.min_payment_pennies, // eslint-disable-line no-restricted-syntax -- Internal field - already in pence
   limit_pennies: updates.limit_pennies, // eslint-disable-line no-restricted-syntax -- Internal field - already in pence
   debt_type: updates.debt_type,
   order_index: updates.order_index
  };
  return upsertDebt(debtUpdate);
 };

 const deleteDebt = async (id) => {
  // Remove from local storage
  try {
   await localDebtStore.deleteDebt(id);
  } catch (error) {
   console.error('Failed to delete debt from local storage:', error);
  }

  // Update state immediately (optimistic update)
  setDebts(prev => prev.filter(debt => debt.id !== id));

  // Best-effort sync with gateway if authenticated
  if (status === 'authenticated') {
   try {
    await gatewayDeleteDebt(id);
   } catch (error) {
    // Swallow error, local delete already happened
    console.warn('Failed to sync debt deletion to server:', error);
   }
  }
 };

 const refreshDebts = () => {};

 // Record a payment with encryption and cloud sync
 const recordPayment = async (paymentData) => {
  try {
   const now = new Date().toISOString();
   
   // Create payment entry
   const paymentEntry = {
    id: `payment_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`,
    debt_id: paymentData.debt_id,
    amount_pennies: paymentData.amount_pennies,
    payment_date: paymentData.payment_date || now.split('T')[0], // YYYY-MM-DD
    payment_type: paymentData.payment_type || 'extra',
    created_at: now,
    updated_at: now,
    notes: paymentData.notes,
    is_demo: isDemo
   };

   // Local-first storage
   await localDebtStore.recordPayment(paymentEntry);
   
   // Update local debt state immediately (optimistic update)
   const debtToUpdate = debts.find(d => d.id === paymentData.debt_id);
   if (debtToUpdate) {
    const newBalance = Math.max(0, (debtToUpdate.amount_pennies || 0) - paymentData.amount_pennies);
    
    setDebts(prev => 
     prev.map(d => 
      d.id === paymentData.debt_id 
       ? { ...d, amount_pennies: newBalance, updated_at: now }
       : d
     )
    );
   }
   
   // Cloud sync for authenticated users
   if (status === 'authenticated') {
    try {
     if (isCryptoAvailable()) {
      // Encrypt payment data for cloud storage
      const encryptionKey = await getOrCreateUserKey();
      await encryptJSON(paymentEntry, encryptionKey);
      
      // Send encrypted payment to cloud (placeholder for actual API call)
      // await sendEncryptedPaymentToCloud(encryptedData);
      console.log('[Payment] Encrypted payment ready for cloud sync');
     } else {
      console.warn('[Payment] Crypto API not available, local-only storage');
     }
    } catch (cloudError) {
     console.warn('[Payment] Cloud sync failed, payment saved locally:', cloudError);
     // Don't throw - local save already succeeded
    }
   }
   
   // Analytics tracking (non-sensitive)
   try {
    // Standardized payment_recorded event
    await secureAnalytics.capturePaymentRecorded({
     debt_id: paymentData.debt_id,
     amount_pennies: paymentData.amount_pennies,
     source: paymentData.payment_type || 'manual'
    });

    // Also capture debt balance update
    await secureAnalytics.captureDebtUpdated(
     fromCents(debtToUpdate?.amount_pennies || 0), // old balance in GBP
     fromCents(Math.max(0, ((debtToUpdate?.amount_pennies || 0) - paymentData.amount_pennies))), // new balance in GBP
     paymentData.debt_id,
     'user-id-placeholder', // TODO: get actual user ID
     'payment-recorded'
    );
   } catch (analyticsError) {
    // Never block payment for analytics failures
    console.debug('[Payment] Analytics tracking failed:', analyticsError);
   }
   
   return paymentEntry;
  } catch (error) {
   console.error('[Payment] Failed to record payment:', error);
   throw error;
  }
 };

 // Dev helper to manually load demo data
 const loadDemoData = async () => {
  try {
   console.log('Manually loading demo data...');
   await localDebtStore.loadDemoData('uk');
   const demoDebts = await localDebtStore.listDebts({ includeDemo: true });
   const safeDebts = safeNormalizeDebts(Array.isArray(demoDebts) ? demoDebts : []);
   updateDebts(safeDebts);
   console.log('Demo data loaded:', safeDebts.length, 'debts');
   return safeDebts;
  } catch (error) {
   console.error('Failed to load demo data:', error);
   throw error;
  }
 };

 // Wrapped API methods with runtime validation
 async function listDebts(...args) {
  const result = await localDebtStore.listDebts(...args);
  if (process.env.NODE_ENV !== 'production') {
   try {
    validateDebts(result, 'listDebts');
   } catch (validationError) {
    console.error('Validation failed in listDebts:', validationError.message);
    // Don't throw in listDebts - return safe normalized data instead
    return safeNormalizeDebts(result);
   }
  }
  return result;
 }

 // Expose to window for debugging
 if (typeof window !== 'undefined' && process.env.NODE_ENV === 'development') {
  window.SB_loadDemoData = loadDemoData;
 }

 // Hydration-aware hasDebts signal - null until hydration complete
 const hasDebts = hydrationStatus === 'ready' ? debts.length > 0 : null;

 return { 
  debts, loading, error, upsertDebt, addDebt, updateDebt, deleteDebt,
  totalDebt, totalMinPayments, paymentHistory, projections,
  isAuthenticated, refreshDebts, loadDemoData, setDebts, listDebts,
  recordPayment, hasDebts, hydrationStatus, syncing
 };
}

export default useUserDebts;
/**
 * Core debt data types for the application
 * Single source of truth for debt structure
 */

// Normalized debt structure (preferred)
export interface NormalizedDebt {
 // Core identifiers 
 id: string;
 name: string;
 type: DebtType;
 
 // Financial data (normalized format)
 amount_pennies: number;    // Balance in pence
 original_amount_pennies: number; // Original amount in pence 
 apr: number;      // APR as percentage (5.5% = 5.5)
 min_payment_pennies: number;  // Minimum payment in pence
 
 // Metadata
 created_at: string; // ISO 8601
 updated_at: string; // ISO 8601
 order_index: number; // For custom sorting
 
 // Optional fields
 is_demo?: boolean;
 notes?: string;
 account_number?: string; // Last 4 digits only
 due_date?: number; // Day of month (1-31)
 credit_limit_pennies?: number; // For credit cards, in pence
}

// Type-level guardrails: prevent legacy fields
type NoLegacyFields = { 
 balance?: never; 
 interestRate?: never; 
 minPayment?: never; 
 amount?: never; 
 apr_pct?: never;
 originalAmount?: never;
 createdAt?: never;
 updatedAt?: never;
 order?: never;
 isDemo?: never;
 creditLimit?: never;
};

// Strict debt type that forbids legacy fields at compile time
export type StrictDebt = NormalizedDebt & NoLegacyFields;

// Legacy debt interface (for backward compatibility only)
export interface Debt {
 // Core identifiers
 id: string;
 name: string;
 type: DebtType;
 
 // Financial data
 balance: number;
 originalAmount: number;
 interestRate: number; // Annual percentage rate
 minPayment: number;
 
 // Metadata
 createdAt: string; // ISO 8601
 updatedAt: string; // ISO 8601
 order: number; // For custom sorting
 
 // Optional fields
 isDemo?: boolean;
 notes?: string;
 accountNumber?: string; // Last 4 digits only
 dueDate?: number; // Day of month (1-31)
 creditLimit?: number; // For credit cards
}

export type DebtType = 
 | 'Credit Card'
 | 'Personal Loan'
 | 'Store Card'
 | 'Overdraft'
 | 'Car Loan'
 | 'Student Loan'
 | 'Mortgage'
 | 'Other';

export interface DebtPayment {
 id: string;
 debtId: string;
 amount: number;
 date: string; // ISO 8601
 month: string; // Format: "2024-01"
 type: 'minimum' | 'extra' | 'snowball';
 createdAt: string;
}

export interface DebtSnapshot {
 debtId: string;
 balance: number;
 timestamp: string; // ISO 8601
 eventType: 'payment' | 'adjustment' | 'interest';
}

export interface MigrationMeta {
 key: string;
 value: any;
 updatedAt: string;
}

// Legacy data structures for migration
export interface LegacyDebt {
 id?: string;
 name?: string;
 balance?: number | string;
 amount?: number | string; // Sometimes used instead of balance
 rate?: number | string;
 interestRate?: number | string;
 interest?: number | string; // Another variant
 minPayment?: number | string;
 min?: number | string; // Short form
 regularPayment?: number | string; // Yet another variant
 type?: string;
 order?: number;
 createdAt?: string;
 updatedAt?: string;
 originalAmount?: number | string;
 isDemo?: boolean;
}

// Validation helpers
export const isValidDebt = (debt: any): debt is Debt => {
 return (
  typeof debt === 'object' &&
  typeof debt.id === 'string' &&
  typeof debt.name === 'string' &&
  typeof debt.amount_pennies === 'number' &&
  typeof debt.apr === 'number' &&
  typeof debt.min_payment_pennies === 'number'
 );
};

export const normalizeAmount = (value: any): number => {
 if (typeof value === 'number') return value;
 if (typeof value === 'string') {
  const parsed = parseFloat(value.replace(/[^0-9.-]/g, ''));
  return isNaN(parsed) ? 0 : parsed;
 }
 return 0;
};

// Runtime dev assertions for normalized data
export function assertNormalized(debt: any, context = 'unknown'): asserts debt is StrictDebt {
 if (process.env.NODE_ENV !== 'development') return;
 
 const legacyFields = ['balance', 'interestRate', 'minPayment', 'amount', 'apr_pct', 
            'originalAmount', 'createdAt', 'updatedAt', 'order', 'isDemo', 'creditLimit'];
 const foundLegacy = legacyFields.filter(field => debt && typeof debt === 'object' && field in debt);
 
 if (foundLegacy.length > 0) {
  console.error(`[DEV] Legacy fields detected in ${context}:`, foundLegacy);
  console.error('Object keys:', Object.keys(debt));
  throw new Error(`Legacy fields detected in ${context}: ${foundLegacy.join(', ')}. Use normalized format.`);
 }
}

// Helper to check if debt is already normalized
export function isNormalized(debt: any): debt is StrictDebt {
 return debt && 
     typeof debt.amount_pennies === 'number' &&
     typeof debt.apr === 'number' &&
     typeof debt.min_payment_pennies === 'number' &&
     !('balance' in debt) &&
     !('interestRate' in debt) &&
     !('minPayment' in debt);
}

// Payment Entry types for secure payment tracking
export interface PaymentEntry {
 id: string;          // UUID
 debt_id: string;       // Reference to debt
 amount_pennies: number;     // Payment amount in pence
 payment_date: string;     // ISO 8601 date
 payment_type: PaymentType;  // Type of payment
 created_at: string;      // ISO 8601 timestamp
 updated_at: string;      // ISO 8601 timestamp
 notes?: string;        // Optional payment notes
 is_demo?: boolean;      // Demo mode flag
}

export type PaymentType = 
 | 'minimum'    // Regular minimum payment
 | 'extra'     // Extra payment towards debt
 | 'snowflake'   // One-time snowflake payment
 | 'adjustment';  // Balance adjustment/correction

// Encrypted payment data for cloud storage
export interface EncryptedPayment {
 id: string;
 user_id: string;
 encrypted_data: string;    // AES-GCM encrypted PaymentEntry
 created_at: string;
 updated_at: string;
}

// Payment summary for analytics (non-sensitive)
export interface PaymentSummary {
 total_payments: number;
 payment_count: number;
 last_payment_date?: string;
 debt_reduction_pennies: number; // Total debt reduction
}
/**
 * fetchWithAuth - 401 Intercepting Fetch Wrapper
 * Automatically detects zombie sessions from backend 401 responses
 * Triggers recovery UI when auth fails but session appears active
 */

import { getToken } from './tokenStorage';

interface FetchWithAuthOptions extends RequestInit {
 skipAuthHeader?: boolean;
 skipZombieDetection?: boolean;
}

interface AuthHeaders {
 Authorization?: string;
 'Content-Type'?: string;
}

/**
 * Enhanced fetch wrapper with automatic 401 zombie session detection
 */
export async function fetchWithAuth(
 url: string, 
 options: FetchWithAuthOptions = {}
): Promise<Response> {
 const { 
  skipAuthHeader = false, 
  skipZombieDetection = false,
  headers: providedHeaders = {},
  ...restOptions 
 } = options;

 // Build headers with auth token (if available and not skipped)
 const headers: AuthHeaders = { ...providedHeaders };
 
 if (!skipAuthHeader) {
  const token = getToken();
  if (token) {
   headers.Authorization = `Bearer ${token}`;
  }
 }

 // Set default content type for JSON requests
 if (!headers['Content-Type'] && 
   (restOptions.method === 'POST' || restOptions.method === 'PUT' || restOptions.method === 'PATCH')) {
  headers['Content-Type'] = 'application/json';
 }

 console.log(`üì° [fetchWithAuth] ${restOptions.method || 'GET'} ${url}`, {
  hasAuth: !!headers.Authorization,
  endpoint: url,
 });

 let response: Response;
 
 try {
  response = await fetch(url, {
   ...restOptions,
   headers: headers as HeadersInit,
   credentials: 'include', // Include cookies for fallback auth
  });
 } catch (networkError) {
  console.error(`‚ùå [fetchWithAuth] Network error for ${url}:`, networkError);
  throw networkError;
 }

 // üö® ZOMBIE SESSION DETECTION
 if (response.status === 401 && !skipZombieDetection) {
  console.warn(`üßü [fetchWithAuth] 401 Unauthorized from ${url}`, {
   hasAuthHeader: !!headers.Authorization,
   responseStatus: response.status,
   url,
  });

  // Check if we're in a potential zombie state
  const hasAuthToken = !!getToken();
  const hasUserInAuth = typeof window !== 'undefined' && 
   (window as any).__AUTH__?.user;

  if (hasAuthToken || hasUserInAuth) {
   console.error('üßü Zombie session detected via 401 response!');
   
   // Dispatch event for zombie session detector
   if (typeof window !== 'undefined') {
    window.dispatchEvent(new CustomEvent('auth-401-detected', {
     detail: {
      endpoint: url,
      hasToken: hasAuthToken,
      hasUserData: hasUserInAuth,
      responseStatus: 401,
     }
    }));
   }
   
   // Track the detection
   if (typeof window !== 'undefined' && (window as any).posthog) {
    (window as any).posthog.capture('fetch_401_zombie_detected', {
     endpoint: url,
     method: restOptions.method || 'GET',
     has_token: hasAuthToken,
     has_user_data: hasUserInAuth,
    });
   }
  }
 }

 // Log response for debugging
 if (!response.ok) {
  console.warn(`‚ö†Ô∏è [fetchWithAuth] ${response.status} ${response.statusText} from ${url}`);
 } else {
  console.log(`‚úÖ [fetchWithAuth] ${response.status} from ${url}`);
 }

 return response;
}

/**
 * Convenience wrapper for JSON API calls
 */
export async function fetchJsonWithAuth<T = any>(
 url: string, 
 options: FetchWithAuthOptions = {}
): Promise<T> {
 const response = await fetchWithAuth(url, options);
 
 if (!response.ok) {
  const errorText = await response.text();
  throw new Error(`HTTP ${response.status}: ${errorText || response.statusText}`);
 }
 
 const contentType = response.headers.get('content-type');
 if (!contentType?.includes('application/json')) {
  throw new Error(`Expected JSON response but got: ${contentType}`);
 }
 
 return await response.json();
}

/**
 * POST helper with JSON body
 */
export async function postJsonWithAuth<T = any>(
 url: string,
 data: any,
 options: FetchWithAuthOptions = {}
): Promise<T> {
 return fetchJsonWithAuth<T>(url, {
  ...options,
  method: 'POST',
  body: JSON.stringify(data),
 });
}

/**
 * PUT helper with JSON body
 */
export async function putJsonWithAuth<T = any>(
 url: string,
 data: any,
 options: FetchWithAuthOptions = {}
): Promise<T> {
 return fetchJsonWithAuth<T>(url, {
  ...options,
  method: 'PUT',
  body: JSON.stringify(data),
 });
}

/**
 * DELETE helper
 */
export async function deleteWithAuth<T = any>(
 url: string,
 options: FetchWithAuthOptions = {}
): Promise<T> {
 return fetchJsonWithAuth<T>(url, {
  ...options,
  method: 'DELETE',
 });
}

/**
 * Legacy compatibility: Replace existing fetch calls gradually
 * 
 * Usage:
 * // Before:
 * const response = await fetch('/api/debts', { method: 'POST', ... });
 * 
 * // After:
 * const response = await fetchWithAuth('/api/debts', { method: 'POST', ... });
 */
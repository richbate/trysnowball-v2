/**
 * Generate a detailed month-by-month payoff timeline.
 * Each entry includes:
 * - month: Month number
 * - totalDebt: Remaining total debt after payments
 * - interestPaid: Interest paid that month
 * - principalPaid: Principal paid that month
 * - remainingDebts: Snapshot of all debts with balances
 *
 * @param {Array<{name: string, amount_pennies: number, apr: number, min_payment_pennies: number}>} debts
 * @param {number} totalPayment - Total monthly payment (minimum + extra)
 * @returns {Array} Timeline entries (up to 120 months)
 */
export const generatePayoffTimeline = (debts, totalPayment) => {
 // Sort by user-defined order first, then by balance as fallback
 const snowballDebts = JSON.parse(JSON.stringify(debts)).sort((a, b) => {
  const orderA = a.order || 999;
  const orderB = b.order || 999;
  if (orderA !== orderB) return orderA - orderB;
  return a.amount_pennies - b.amount_pennies; // Fallback to amount if orders are equal
 });
 const totalDebt = snowballDebts.reduce((sum, d) => sum + d.amount_pennies, 0);
 const timeline = [];

 if (totalPayment >= totalDebt) {
  // Immediate payoff
  timeline.push({
   month: 1,
   totalDebt: 0,
   interestPaid: 0,
   principalPaid: totalDebt,
   remainingDebts: snowballDebts.map(d => ({ name: d.name, amount_pennies: 0 })),
  });
  return timeline;
 }

 for (let month = 1; month <= 120; month++) {
  let available = totalPayment;
  let totalInterestPaid = 0;
  let totalPrincipalPaid = 0;

  // Step 1: Apply interest + minimum payments
  for (let i = 0; i < snowballDebts.length; i++) {
   const debt = snowballDebts[i];
   if (debt.amount_pennies <= 0) continue;

   const interest = Math.round(debt.amount_pennies * (debt.apr / 100 / 12 / 100) * 100) / 100;
   debt.amount_pennies += interest;
   totalInterestPaid += interest;

   const minPayment = Math.min(debt.amount_pennies, debt.min_payment_pennies);
   debt.amount_pennies = Math.max(0, debt.amount_pennies - minPayment);
   totalPrincipalPaid += Math.max(minPayment - interest, 0);

   available -= minPayment;
  }

  available = Math.max(0, available);

  // Step 2: Apply extra to smallest debt
  if (available > 0) {
   for (let i = 0; i < snowballDebts.length; i++) {
    if (snowballDebts[i].amount_pennies > 0) {
     const extraPayment = Math.min(available, snowballDebts[i].amount_pennies);
     snowballDebts[i].amount_pennies = Math.max(0, snowballDebts[i].amount_pennies - extraPayment);
     totalPrincipalPaid += extraPayment;
     break;
    }
   }
  }

  const totalRemaining = snowballDebts.reduce((sum, d) => sum + d.amount_pennies, 0);

  timeline.push({
   month,
   totalDebt: Math.round(totalRemaining * 100) / 100,
   interestPaid: Math.round(totalInterestPaid * 100) / 100,
   principalPaid: Math.round(totalPrincipalPaid * 100) / 100,
   remainingDebts: snowballDebts.map(d => ({ name: d.name, amount_pennies: Math.round(d.amount_pennies * 100) / 100 })),
  });

  if (totalRemaining <= 1) break; // All debts cleared
 }

 return timeline;
};
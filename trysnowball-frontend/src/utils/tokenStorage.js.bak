/**
 * Centralized Token Storage Utility
 * Single source of truth for JWT token storage key and operations
 * Prevents key mismatches and provides consistent error handling
 */

const NEW_JWT_STORAGE_KEY = 'ts_jwt';
const OLD_JWT_STORAGE_KEY = 'token'; // Backward compatibility

/**
 * Get the token from localStorage with backward compatibility and cookie fallback
 * @returns {string|null} The stored token or null if not found/error
 */
export const getToken = () => {
 try {
  // Try new key first
  let token = localStorage.getItem(NEW_JWT_STORAGE_KEY);
  if (token) {
   console.log('[TokenStorage] Token found with new key');
   return token;
  }
  
  // Fallback to old key for backward compatibility
  token = localStorage.getItem(OLD_JWT_STORAGE_KEY);
  if (token) {
   console.log('[TokenStorage] Token found with old key, migrating');
   // Migrate to new key
   localStorage.setItem(NEW_JWT_STORAGE_KEY, token);
   localStorage.removeItem(OLD_JWT_STORAGE_KEY);
   return token;
  }

  // Fallback to httpOnly cookie (ts_session) set by auth worker
  const cookies = document.cookie.split(';');
  const sessionCookie = cookies.find(c => c.trim().startsWith('ts_session='));
  if (sessionCookie) {
   token = sessionCookie.split('=')[1];
   console.log('[TokenStorage] Token found in httpOnly cookie, storing in localStorage');
   // Store in localStorage for consistency
   localStorage.setItem(NEW_JWT_STORAGE_KEY, token);
   return token;
  }
  
  console.log('[TokenStorage] No token found in localStorage');
  return null;
 } catch (err) {
  console.error('[TokenStorage] Error reading token:', err);
  return null;
 }
};

/**
 * Save the token to localStorage using new key
 * @param {string|null} token - The token to store, or null/undefined to remove
 */
export const setToken = (token) => {
 try {
  if (token) {
   console.log('[TokenStorage] Storing token in localStorage');
   localStorage.setItem(NEW_JWT_STORAGE_KEY, token);
   // Clean up old key during migration
   localStorage.removeItem(OLD_JWT_STORAGE_KEY);
   console.log('[TokenStorage] Token stored successfully');
  } else {
   console.log('[TokenStorage] Clearing token from localStorage');
   localStorage.removeItem(NEW_JWT_STORAGE_KEY);
   localStorage.removeItem(OLD_JWT_STORAGE_KEY); // Clean both
  }
 } catch (err) {
  console.error('[TokenStorage] Error writing token:', err);
 }
};

/**
 * Remove the token from localStorage
 * Alias for setToken(null) for clearer intent
 */
export const clearToken = () => {
 try {
  localStorage.removeItem(NEW_JWT_STORAGE_KEY);
  localStorage.removeItem(OLD_JWT_STORAGE_KEY); // Clean both for migration
 } catch (err) {
  console.error('Error clearing token:', err);
 }
};

/**
 * Check if a token exists in storage
 * @returns {boolean} True if token exists, false otherwise
 */
export const hasToken = () => {
 return !!getToken();
};

/**
 * Decode JWT payload without verification (client-side only)
 * @param {string} token - JWT token
 * @returns {object|null} Decoded payload or null if invalid
 */
export const decodeJWT = (token) => {
 try {
  if (!token) return null;
  const parts = token.split('.');
  if (parts.length !== 3) return null;
  
  const payload = parts[1];
  // Add padding if needed
  const padded = payload + '='.repeat((4 - payload.length % 4) % 4);
  const decoded = atob(padded);
  return JSON.parse(decoded);
 } catch (err) {
  console.warn('[TokenStorage] Error decoding JWT:', err);
  return null;
 }
};

/**
 * Check if token is expired or will expire soon
 * @param {number} bufferMinutes - Minutes before expiry to consider "will expire soon"
 * @returns {object} { isExpired: boolean, expiresAt: Date|null, timeToExpiry: number }
 */
export const getTokenExpiry = (bufferMinutes = 60) => {
 const token = getToken();
 if (!token) {
  return { isExpired: true, expiresAt: null, timeToExpiry: 0 };
 }
 
 const payload = decodeJWT(token);
 if (!payload || !payload.exp) {
  return { isExpired: true, expiresAt: null, timeToExpiry: 0 };
 }
 
 const expiresAt = new Date(payload.exp * 1000);
 const now = new Date();
 const timeToExpiry = Math.floor((expiresAt - now) / 1000 / 60); // minutes
 const isExpired = timeToExpiry <= bufferMinutes;
 
 return {
  isExpired,
  expiresAt,
  timeToExpiry
 };
};

/**
 * Refresh the JWT token using the /auth/refresh endpoint
 * @returns {Promise<boolean>} True if refresh succeeded, false otherwise
 */
export const refreshToken = async () => {
 try {
  const currentToken = getToken();
  if (!currentToken) {
   console.warn('[TokenStorage] No token to refresh');
   return false;
  }
  
  console.log('[TokenStorage] Attempting token refresh...');
  
  const response = await fetch('/auth/refresh', {
   method: 'POST',
   headers: {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${currentToken}`
   },
   credentials: 'include'
  });
  
  if (!response.ok) {
   console.error('[TokenStorage] Token refresh failed:', response.status, response.statusText);
   return false;
  }
  
  const data = await response.json();
  if (data.token) {
   setToken(data.token);
   console.log('[TokenStorage] Token refreshed successfully');
   
   // Dispatch event for other parts of app to know token was refreshed
   if (typeof window !== 'undefined') {
    window.dispatchEvent(new CustomEvent('token-refreshed', { 
     detail: { newToken: data.token } 
    }));
   }
   
   return true;
  } else {
   console.error('[TokenStorage] Refresh response missing token');
   return false;
  }
 } catch (err) {
  console.error('[TokenStorage] Token refresh error:', err);
  return false;
 }
};
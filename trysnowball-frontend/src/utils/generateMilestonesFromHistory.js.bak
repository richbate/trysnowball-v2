// Utility to generate dynamic milestone achievements from debt history

/**
 * Generates milestone achievements based on actual debt history
 * @param {Array} debts - Array of debt objects with history
 * @returns {Array} Array of milestone objects sorted by achievement date
 */
export const generateMilestonesFromHistory = (debts) => {
 if (!debts || debts.length === 0) return [];

 const milestones = [];

 // Process each debt for individual achievements
 debts.forEach(debt => {
  const history = debt.history || [];
  if (history.length < 2) return; // Need at least 2 history points

  // Sort history by date
  const sortedHistory = [...history].sort((a, b) => 
   new Date(a.changedAt || a.date) - new Date(b.changedAt || b.date)
  );

  const firstEntry = sortedHistory[0];
  const latestEntry = sortedHistory[sortedHistory.length - 1];
  const currentBalance = debt.amount_pennies || debt.amount || latestEntry.balance;
  
  // Check for debt payoff
  if (firstEntry.balance > 0 && currentBalance <= 0) {
   milestones.push({
    milestoneId: `payoff_${debt.name.toLowerCase().replace(/\s+/g, '_')}`,
    title: `🎉 ${debt.name} PAID OFF!`,
    description: `Congratulations! You've completely paid off ${debt.name} (was £${Math.round(firstEntry.balance).toLocaleString()})`,
    achievedAt: latestEntry.changedAt || latestEntry.date,
    type: 'payoff',
    amount: firstEntry.balance,
    priority: 10 // Highest priority
   });
  }
  
  // Check for significant reductions (>£500 in any period)
  const totalReduction = firstEntry.balance - currentBalance;
  if (totalReduction > 500 && currentBalance > 0) {
   const monthsTracked = Math.max(1, Math.round(
    (new Date(latestEntry.changedAt || latestEntry.date) - new Date(firstEntry.changedAt || firstEntry.date)) 
    / (1000 * 60 * 60 * 24 * 30)
   ));
   
   milestones.push({
    milestoneId: `progress_${debt.name.toLowerCase().replace(/\s+/g, '_')}`,
    title: `📉 ${debt.name} Major Progress!`,
    description: `Reduced ${debt.name} by £${Math.round(totalReduction).toLocaleString()} over ${monthsTracked} month${monthsTracked > 1 ? 's' : ''}`,
    achievedAt: latestEntry.changedAt || latestEntry.date,
    type: 'major_progress',
    amount: totalReduction,
    priority: 7
   });
  }

  // Check for biggest 3-month reduction periods
  if (sortedHistory.length >= 3) {
   let biggestReduction = 0;
   let biggestReductionPeriod = null;
   
   for (let i = 0; i < sortedHistory.length - 2; i++) {
    const startBalance = sortedHistory[i].balance;
    const endBalance = sortedHistory[i + 2].balance;
    const reduction = startBalance - endBalance;
    
    if (reduction > biggestReduction && reduction > 200) {
     biggestReduction = reduction;
     biggestReductionPeriod = {
      start: sortedHistory[i],
      end: sortedHistory[i + 2]
     };
    }
   }
   
   if (biggestReductionPeriod && biggestReduction > 200) {
    milestones.push({
     milestoneId: `best_period_${debt.name.toLowerCase().replace(/\s+/g, '_')}`,
     title: `🚀 ${debt.name} Best Period!`,
     description: `Your best progress period: £${Math.round(biggestReduction).toLocaleString()} reduction`,
     achievedAt: biggestReductionPeriod.end.changedAt || biggestReductionPeriod.end.date,
     type: 'best_period',
     amount: biggestReduction,
     priority: 5
    });
   }
  }
 });

 // Calculate overall portfolio milestones
 const totalOriginal = debts.reduce((sum, debt) => {
  const history = debt.history || [];
  if (history.length === 0) return sum;
  const firstEntry = history.sort((a, b) => 
   new Date(a.changedAt || a.date) - new Date(b.changedAt || b.date)
  )[0];
  return sum + firstEntry.balance;
 }, 0);

 const totalCurrent = debts.reduce((sum, debt) => 
  sum + (debt.amount_pennies || debt.amount || 0), 0
 );

 const totalReduction = totalOriginal - totalCurrent;

 // Overall portfolio milestones
 if (totalReduction > 1000) {
  milestones.push({
   milestoneId: 'total_portfolio_progress',
   title: `💪 £${Math.round(totalReduction).toLocaleString()} Total Debt Reduction!`,
   description: `Amazing work! You've reduced your total debt by £${Math.round(totalReduction).toLocaleString()}`,
   achievedAt: new Date().toISOString(),
   type: 'portfolio_progress',
   amount: totalReduction,
   priority: 8
  });
 }

 // Check if halfway to debt freedom
 const progressPercentage = totalOriginal > 0 ? (totalReduction / totalOriginal) * 100 : 0;
 if (progressPercentage >= 50 && progressPercentage < 75) {
  milestones.push({
   milestoneId: 'halfway_milestone',
   title: `🎯 Halfway to Debt Freedom!`,
   description: `You're ${Math.round(progressPercentage)}% of the way to being debt-free!`,
   achievedAt: new Date().toISOString(),
   type: 'halfway',
   amount: progressPercentage,
   priority: 9
  });
 }

 // Check for debt-free achievement
 if (totalCurrent <= 0 && totalOriginal > 0) {
  milestones.push({
   milestoneId: 'debt_free',
   title: `🏆 DEBT FREE! You did it!`,
   description: `Congratulations! You've paid off all £${Math.round(totalOriginal).toLocaleString()} of your debt!`,
   achievedAt: new Date().toISOString(),
   type: 'debt_free',
   amount: totalOriginal,
   priority: 10
  });
 }

 // Check for consecutive months of progress
 const hasConsecutiveProgress = checkConsecutiveProgress(debts);
 if (hasConsecutiveProgress.months >= 3) {
  milestones.push({
   milestoneId: 'consistency_streak',
   title: `🔥 ${hasConsecutiveProgress.months} Month Consistency Streak!`,
   description: `You've made progress for ${hasConsecutiveProgress.months} consecutive months!`,
   achievedAt: new Date().toISOString(),
   type: 'consistency',
   amount: hasConsecutiveProgress.months,
   priority: 6
  });
 }

 // Sort by priority (highest first) and date (most recent first)
 return milestones
  .sort((a, b) => {
   if (a.priority !== b.priority) return b.priority - a.priority;
   return new Date(b.achievedAt) - new Date(a.achievedAt);
  })
  .slice(0, 5); // Limit to 5 most important milestones
};

/**
 * Helper function to check for consecutive months of progress
 * @param {Array} debts - Array of debt objects
 * @returns {Object} Object with consecutive months count
 */
const checkConsecutiveProgress = (debts) => {
 // This is a simplified version - could be enhanced to check actual monthly progress
 let maxConsecutiveMonths = 0;
 
 debts.forEach(debt => {
  const history = debt.history || [];
  if (history.length < 3) return;
  
  const sortedHistory = [...history].sort((a, b) => 
   new Date(a.changedAt || a.date) - new Date(b.changedAt || b.date)
  );
  
  let consecutiveCount = 0;
  for (let i = 1; i < sortedHistory.length; i++) {
   const previous = sortedHistory[i - 1].balance;
   const current = sortedHistory[i].balance;
   
   if (current < previous) {
    consecutiveCount++;
   } else {
    maxConsecutiveMonths = Math.max(maxConsecutiveMonths, consecutiveCount);
    consecutiveCount = 0;
   }
  }
  maxConsecutiveMonths = Math.max(maxConsecutiveMonths, consecutiveCount);
 });
 
 return { months: maxConsecutiveMonths };
};

/**
 * Generate milestone for specific achievement types
 * @param {string} type - Type of milestone to generate
 * @param {Array} debts - Array of debt objects
 * @returns {Object|null} Milestone object or null
 */
export const generateSpecificMilestone = (type, debts) => {
 const allMilestones = generateMilestonesFromHistory(debts);
 return allMilestones.find(milestone => milestone.type === type) || null;
};

/**
 * Check if a milestone should be displayed (not too old)
 * @param {Object} milestone - Milestone object
 * @param {number} maxDaysOld - Maximum days old to display (default 90)
 * @returns {boolean} Whether milestone should be shown
 */
export const shouldDisplayMilestone = (milestone, maxDaysOld = 90) => {
 const achievedDate = new Date(milestone.achievedAt);
 const now = new Date();
 const daysDiff = (now - achievedDate) / (1000 * 60 * 60 * 24);
 
 // Always show payoffs and debt-free achievements
 if (milestone.type === 'payoff' || milestone.type === 'debt_free') {
  return daysDiff <= 365; // Show for a full year
 }
 
 return daysDiff <= maxDaysOld;
};